{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nWelcome to the Paperino display docs! The documentation is divided into the following sections:\n\n\n\n\nHookup Guide\n - Step-by-step instructions to get your Paperino setup and run within minutes.\n\n\nExamples\n - Ready to use examples for your own inspiration.\n\n\nReference\n - Datasheets \n Application Notes.\n\n\nProduct repository\n - Main Github repository including hardware files \n documentation.\n\n\n\n\nHaving problems or have awesome suggestions? Contact us: display.paperino@gmail.com.\n\n\nProjects", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Welcome to the Paperino display docs! The documentation is divided into the following sections:   Hookup Guide  - Step-by-step instructions to get your Paperino setup and run within minutes.  Examples  - Ready to use examples for your own inspiration.  Reference  - Datasheets   Application Notes.  Product repository  - Main Github repository including hardware files   documentation.   Having problems or have awesome suggestions? Contact us: display.paperino@gmail.com.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#projects", 
            "text": "", 
            "title": "Projects"
        }, 
        {
            "location": "/hookupOverview/", 
            "text": "So, what is Paperino?\n\n\nModern \nePaper displays (EPDs)\n combine cutting edge technology with the known, century-old experience of paper. They can display text and graphics without any power, which makes them ideal for \nultra-low power and battery driven projects\n. However, integrating an ePaper display into your project can be complex due to the need for several high voltages and waveforms. Paperino \nsimplifies\n driving ePaper displays with clean, simple, and short script examples. This lets makers of all ages - from kids learning Arduino, to engineers and developers building with Particle, use ePapers for their next project!\n\n\n\n\nParticle Shield (PnP)\n\n\nThe ePaper display shield for the \nParticle MCU family\n allows you to start playing within minutes without the need of manual wiring. It supports \nParticle Photon, Electron\n and \nBluz.io\n. The shield can be combined with other Particle shields like the battery shield for example. If you want to know how to connect the shield with your Particle device then please continue reading the Hookup guide \nhere\n.\n\n\n\n\nBreakout Board\n\n\nFurther Arduino-compatible microcontroller can be hooked-up with the universal ePaper breakout-board. So far it was tested with NodeMCU, WeMos D2 mini  and the new Arduino MKRFOX1200. Generally it should work with all Arduino-compatible MCUs having at least 4kb SRAM, 3.3V pinouts and sufficiently free GPIOs!\n\n\n\n\nDriver Module\n\n\nThe driver module is the heart of Paperino and contains the electronics to drive the ePaper display. The module can be incorporated to your own PCB designs. Soldering skills are of course needed!", 
            "title": "Overview"
        }, 
        {
            "location": "/hookupOverview/#so-what-is-paperino", 
            "text": "Modern  ePaper displays (EPDs)  combine cutting edge technology with the known, century-old experience of paper. They can display text and graphics without any power, which makes them ideal for  ultra-low power and battery driven projects . However, integrating an ePaper display into your project can be complex due to the need for several high voltages and waveforms. Paperino  simplifies  driving ePaper displays with clean, simple, and short script examples. This lets makers of all ages - from kids learning Arduino, to engineers and developers building with Particle, use ePapers for their next project!", 
            "title": "So, what is Paperino?"
        }, 
        {
            "location": "/hookupOverview/#particle-shield-pnp", 
            "text": "The ePaper display shield for the  Particle MCU family  allows you to start playing within minutes without the need of manual wiring. It supports  Particle Photon, Electron  and  Bluz.io . The shield can be combined with other Particle shields like the battery shield for example. If you want to know how to connect the shield with your Particle device then please continue reading the Hookup guide  here .", 
            "title": "Particle Shield (PnP)"
        }, 
        {
            "location": "/hookupOverview/#breakout-board", 
            "text": "Further Arduino-compatible microcontroller can be hooked-up with the universal ePaper breakout-board. So far it was tested with NodeMCU, WeMos D2 mini  and the new Arduino MKRFOX1200. Generally it should work with all Arduino-compatible MCUs having at least 4kb SRAM, 3.3V pinouts and sufficiently free GPIOs!", 
            "title": "Breakout Board"
        }, 
        {
            "location": "/hookupOverview/#driver-module", 
            "text": "The driver module is the heart of Paperino and contains the electronics to drive the ePaper display. The module can be incorporated to your own PCB designs. Soldering skills are of course needed!", 
            "title": "Driver Module"
        }, 
        {
            "location": "/hookupEPD/", 
            "text": "The ePaper hookup guide\n\n\nIn this tutorial we\u2019ll give you a brief introduction to the Paperino ePaper display and the breakout board, then we\u2019ll jump into example hardware hookups and code. The tutorial is split into the following sections:\n\n\n\n\nBreakout Board\n \u2013 To begin, we\u2019ll go over each of the pins on the breakout board and their function. \n\n\nHardware hookup\n \u2013 In this section we\u2019ll show you how to hook an Arduino up to the display via SPI.\n\n\nUsing the Adafruit Library\n \u2013 A quick examination of the Micro ePaper family of function calls.\n\n\nFirst Example: Hello World!\n \u2013 The first complete example\u2026 let\u2019s make the display blink!\n\n\n\n\nBeside the ePaper breakout board, you\u2019ll need something to control the display. Optimally you\u2019ll want something that has a 3.3V operating voltage. We\u2019ll be using a Particle Photon as an example, which generates and exposes 3V3 on one of the pins.\n\n\nePaper display\n\n\nThe ePaper display from Plastic Logic is an eInk-based EPD with 148x70 pixel resolution. It keeps its image content stable without any power, so its perfect for your next connected, ultra-low power project. The display is super thin (less than half a millimeter) and weights just 1.2g!! Actually it\u2019s even bendable, so start thinking now about your next curved product!? ;-)\n\n\n\n\nBreakout Board\n\n\nThe breakout board is the physical interface between the ePaper display and your MCU. It contains a small circuitry to generate the voltages which are needed to switch an ePaper screen. Furthermore it integrates an accelerometer (BMA250) which allows to add additional functionality (like tap detection, portrait/landscape detection, \u2026)\n\n\n\n\nThe breakout board provides access to 12 pins. To start with, you\u2019ll only need the first nine pins to make the display work and two further pin to activate the integrated accelerometer. The following table provides an overview of the used pins:\n\n\n\n\n\n\n\n\n#\n\n\nPin\n\n\nFunction\n\n\nPhoton (example)\n\n\n\n\n\n\n\n\n\n\n1\n\n\nMOS\n\n\nSPI MOSI\n\n\nD2\n\n\n\n\n\n\n2\n\n\nMIS\n\n\nSPI MISO\n\n\nD3\n\n\n\n\n\n\n3\n\n\nCLK\n\n\nSPI clock\n\n\nD4\n\n\n\n\n\n\n4\n\n\nCS1\n\n\nSPI chip select for ePaper driver IC\n\n\nD5 or any other free pin\n\n\n\n\n\n\n5\n\n\nRST\n\n\nDigital pin to reset driver IC UC8156\n\n\nA0 or any other free pin\n\n\n\n\n\n\n6\n\n\nBSY\n\n\nDigital pin to sense activity state of driver IC UC8156\n\n\nA1 or any other free pin\n\n\n\n\n\n\n7\n\n\n3V3\n\n\nRegulated 3.3V power supply\n\n\n3V3\n\n\n\n\n\n\n8\n\n\nGND\n\n\nGround\n\n\nGND\n\n\n\n\n\n\n9\n\n\n-\n\n\n(unused)\n\n\n(unused)\n\n\n\n\n\n\n10\n\n\nCS2\n\n\nSPI chip select for accelerometer IC\n\n\nD0 or any other free pin\n\n\n\n\n\n\n11\n\n\nIN2\n\n\nInterrupt line #2, e.g. for tap sensing\n\n\nA7 or any other free pin\n\n\n\n\n\n\n12\n\n\nIN1\n\n\nInterrupt line #1, e.g. for wake-up of deep sleeping MCU\n\n\nA7\n\n\n\n\n\n\n\n\nYou can wire-up the two remaining pins called IN1 and IN2 later-on. They are required if you want to wake-up your MCU from deep-sleeping, if for example an motion is detected and/or for sensing finger taps on the screen.\n\n\nHardware hookup\n\n\nNow it\u2019s time to wire it up! In this section we\u2019ll go over the hookup, based on an Particle Photon. We\u2019ll be using Particle\u2019s hardware SPI pins in order to achieve the fastest data transfer speed. That means we\u2019ll need to use pins for SPI connection as described in the table above. The other pins \u2013 RST, BSY, CS1/CS2 and IN1/IN2 \u2013 can be connected to any available digital pin on the Photon.\n\n\nHere\u2019s the example hookup:\n\n\n\n\nUsing the Adafruit GFX Library\n\n\nNow that we have wired-up the Paperino breakout board with the MCU, it\u2019s time to get started writing your own application! Before you get started, here\u2019s a quick overview of the \nPL_microEPD\n library.\n\n\nAt the top of your code, you\u2019ll need to include the Adafruit GFX library together with a library supporting additional fonts (thanks! to Paul Kourany). Finally, you should add the library \nPL_microEPD\n which takes care of the communication to the ePaper display in the background. \n\n\n#include \"Adafruit_mfGFX.h\"\n#include \"fonts.h\"\n#include \"PL_microEPD.h\"\n\n\n\nAfter you have included the library, you can create an object \ndisplay\n in the global variable area of your code. Now its also time to define the pin mapping:\n\n\n#define EPD_RST     A0      //Reset pin, used to restart the driver IC\n#define EPD_BUSY    A1      //Busy pin, used to sense the activity state of the driver IC\n#define EPD_CS      D5      //Chip select pin, used to select the EPD driver IC\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);\n\n\n\nIn the example above we\u2019ve called our \nPL_MicroEPD\n object \ndisplay\n, but you can call it anything you\u2019d like. You can even create more than one, if you have more displays connected to your MCU.\n\n\nThe last step to the Paperino setup should occur in the setup() function. Stick a \ndisplay.begin()\n function in there, which will initialise the display and update all sorts of behind-the-scenes settings for you.\n\n\nsetup() {\n    display.begin();        //Configure Paperino and all of it\u2019s pins\n}\n\n\n\nFirst Example: Hello World!\n\n\nNow we are ready to let the display blink! You can use the \nprint()\n command to write your first text in the screen buffer:\n\n\ndisplay.print(\u201cHello World!\u201d);      //Writes the text \u201cHello World!\u201d into the image buffer\ndisplay.updateFull();               //Refreshing display with the content of the image buffer\n\n\n\nThe command \nupdateFull()\n actually triggers the ePaper refresh, displaying the content of the image buffer finally. That\u2019s it! To summarise everything, you can now see the complete code here:\n\n\n//PAPERINO: Hello World example for the Paperino Micro ePaper breakoutboard\n\n#include \"Adafruit_mfGFX.h\"\n#include \"PLD_tinyEPD.h\"\n#include \"fonts.h\"\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      D5\n\nPL_tinyEPD display(EPD_CS, EPD_RST, EPD_BUSY);\n\nvoid setup() {\n    SPI1.begin();\n    SPI1.setBitOrder(MSBFIRST);                 \n    SPI1.setDataMode(SPI_MODE0); \n    SPI1.setClockDivider(SPI_CLOCK_DIV4);\n    display.begin(true);\n    display.print(\u201cHello World!\u201d);\n    display.updateFull();\n}\n\nvoid loop() {\n    }\n\n\n\nThat was easy, right? If you want to proceed with the setup of the integrated accelerometer let\u2019s continue with the accelerometer hook-up guide.\nIf you are interested in how to write more complex features on the ePaper we suggest starting with the examples section.", 
            "title": "Particle Web-IDE"
        }, 
        {
            "location": "/hookupEPD/#the-epaper-hookup-guide", 
            "text": "In this tutorial we\u2019ll give you a brief introduction to the Paperino ePaper display and the breakout board, then we\u2019ll jump into example hardware hookups and code. The tutorial is split into the following sections:   Breakout Board  \u2013 To begin, we\u2019ll go over each of the pins on the breakout board and their function.   Hardware hookup  \u2013 In this section we\u2019ll show you how to hook an Arduino up to the display via SPI.  Using the Adafruit Library  \u2013 A quick examination of the Micro ePaper family of function calls.  First Example: Hello World!  \u2013 The first complete example\u2026 let\u2019s make the display blink!   Beside the ePaper breakout board, you\u2019ll need something to control the display. Optimally you\u2019ll want something that has a 3.3V operating voltage. We\u2019ll be using a Particle Photon as an example, which generates and exposes 3V3 on one of the pins.", 
            "title": "The ePaper hookup guide"
        }, 
        {
            "location": "/hookupEPD/#epaper-display", 
            "text": "The ePaper display from Plastic Logic is an eInk-based EPD with 148x70 pixel resolution. It keeps its image content stable without any power, so its perfect for your next connected, ultra-low power project. The display is super thin (less than half a millimeter) and weights just 1.2g!! Actually it\u2019s even bendable, so start thinking now about your next curved product!? ;-)", 
            "title": "ePaper display"
        }, 
        {
            "location": "/hookupEPD/#breakout-board", 
            "text": "The breakout board is the physical interface between the ePaper display and your MCU. It contains a small circuitry to generate the voltages which are needed to switch an ePaper screen. Furthermore it integrates an accelerometer (BMA250) which allows to add additional functionality (like tap detection, portrait/landscape detection, \u2026)   The breakout board provides access to 12 pins. To start with, you\u2019ll only need the first nine pins to make the display work and two further pin to activate the integrated accelerometer. The following table provides an overview of the used pins:     #  Pin  Function  Photon (example)      1  MOS  SPI MOSI  D2    2  MIS  SPI MISO  D3    3  CLK  SPI clock  D4    4  CS1  SPI chip select for ePaper driver IC  D5 or any other free pin    5  RST  Digital pin to reset driver IC UC8156  A0 or any other free pin    6  BSY  Digital pin to sense activity state of driver IC UC8156  A1 or any other free pin    7  3V3  Regulated 3.3V power supply  3V3    8  GND  Ground  GND    9  -  (unused)  (unused)    10  CS2  SPI chip select for accelerometer IC  D0 or any other free pin    11  IN2  Interrupt line #2, e.g. for tap sensing  A7 or any other free pin    12  IN1  Interrupt line #1, e.g. for wake-up of deep sleeping MCU  A7     You can wire-up the two remaining pins called IN1 and IN2 later-on. They are required if you want to wake-up your MCU from deep-sleeping, if for example an motion is detected and/or for sensing finger taps on the screen.", 
            "title": "Breakout Board"
        }, 
        {
            "location": "/hookupEPD/#hardware-hookup", 
            "text": "Now it\u2019s time to wire it up! In this section we\u2019ll go over the hookup, based on an Particle Photon. We\u2019ll be using Particle\u2019s hardware SPI pins in order to achieve the fastest data transfer speed. That means we\u2019ll need to use pins for SPI connection as described in the table above. The other pins \u2013 RST, BSY, CS1/CS2 and IN1/IN2 \u2013 can be connected to any available digital pin on the Photon.  Here\u2019s the example hookup:", 
            "title": "Hardware hookup"
        }, 
        {
            "location": "/hookupEPD/#using-the-adafruit-gfx-library", 
            "text": "Now that we have wired-up the Paperino breakout board with the MCU, it\u2019s time to get started writing your own application! Before you get started, here\u2019s a quick overview of the  PL_microEPD  library.  At the top of your code, you\u2019ll need to include the Adafruit GFX library together with a library supporting additional fonts (thanks! to Paul Kourany). Finally, you should add the library  PL_microEPD  which takes care of the communication to the ePaper display in the background.   #include \"Adafruit_mfGFX.h\"\n#include \"fonts.h\"\n#include \"PL_microEPD.h\"  After you have included the library, you can create an object  display  in the global variable area of your code. Now its also time to define the pin mapping:  #define EPD_RST     A0      //Reset pin, used to restart the driver IC\n#define EPD_BUSY    A1      //Busy pin, used to sense the activity state of the driver IC\n#define EPD_CS      D5      //Chip select pin, used to select the EPD driver IC\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  In the example above we\u2019ve called our  PL_MicroEPD  object  display , but you can call it anything you\u2019d like. You can even create more than one, if you have more displays connected to your MCU.  The last step to the Paperino setup should occur in the setup() function. Stick a  display.begin()  function in there, which will initialise the display and update all sorts of behind-the-scenes settings for you.  setup() {\n    display.begin();        //Configure Paperino and all of it\u2019s pins\n}", 
            "title": "Using the Adafruit GFX Library"
        }, 
        {
            "location": "/hookupEPD/#first-example-hello-world", 
            "text": "Now we are ready to let the display blink! You can use the  print()  command to write your first text in the screen buffer:  display.print(\u201cHello World!\u201d);      //Writes the text \u201cHello World!\u201d into the image buffer\ndisplay.updateFull();               //Refreshing display with the content of the image buffer  The command  updateFull()  actually triggers the ePaper refresh, displaying the content of the image buffer finally. That\u2019s it! To summarise everything, you can now see the complete code here:  //PAPERINO: Hello World example for the Paperino Micro ePaper breakoutboard\n\n#include \"Adafruit_mfGFX.h\"\n#include \"PLD_tinyEPD.h\"\n#include \"fonts.h\"\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      D5\n\nPL_tinyEPD display(EPD_CS, EPD_RST, EPD_BUSY);\n\nvoid setup() {\n    SPI1.begin();\n    SPI1.setBitOrder(MSBFIRST);                 \n    SPI1.setDataMode(SPI_MODE0); \n    SPI1.setClockDivider(SPI_CLOCK_DIV4);\n    display.begin(true);\n    display.print(\u201cHello World!\u201d);\n    display.updateFull();\n}\n\nvoid loop() {\n    }  That was easy, right? If you want to proceed with the setup of the integrated accelerometer let\u2019s continue with the accelerometer hook-up guide.\nIf you are interested in how to write more complex features on the ePaper we suggest starting with the examples section.", 
            "title": "First Example: Hello World!"
        }, 
        {
            "location": "/hookupEPD/", 
            "text": "The ePaper hookup guide\n\n\nIn this tutorial we\u2019ll give you a brief introduction to the Paperino ePaper display and the breakout board, then we\u2019ll jump into example hardware hookups and code. The tutorial is split into the following sections:\n\n\n\n\nBreakout Board\n \u2013 To begin, we\u2019ll go over each of the pins on the breakout board and their function. \n\n\nHardware hookup\n \u2013 In this section we\u2019ll show you how to hook an Arduino up to the display via SPI.\n\n\nUsing the Adafruit Library\n \u2013 A quick examination of the Micro ePaper family of function calls.\n\n\nFirst Example: Hello World!\n \u2013 The first complete example\u2026 let\u2019s make the display blink!\n\n\n\n\nBeside the ePaper breakout board, you\u2019ll need something to control the display. Optimally you\u2019ll want something that has a 3.3V operating voltage. We\u2019ll be using a Particle Photon as an example, which generates and exposes 3V3 on one of the pins.\n\n\nePaper display\n\n\nThe ePaper display from Plastic Logic is an eInk-based EPD with 148x70 pixel resolution. It keeps its image content stable without any power, so its perfect for your next connected, ultra-low power project. The display is super thin (less than half a millimeter) and weights just 1.2g!! Actually it\u2019s even bendable, so start thinking now about your next curved product!? ;-)\n\n\n\n\nBreakout Board\n\n\nThe breakout board is the physical interface between the ePaper display and your MCU. It contains a small circuitry to generate the voltages which are needed to switch an ePaper screen. Furthermore it integrates an accelerometer (BMA250) which allows to add additional functionality (like tap detection, portrait/landscape detection, \u2026)\n\n\n\n\nThe breakout board provides access to 12 pins. To start with, you\u2019ll only need the first nine pins to make the display work and two further pin to activate the integrated accelerometer. The following table provides an overview of the used pins:\n\n\n\n\n\n\n\n\n#\n\n\nPin\n\n\nFunction\n\n\nPhoton (example)\n\n\n\n\n\n\n\n\n\n\n1\n\n\nMOS\n\n\nSPI MOSI\n\n\nD2\n\n\n\n\n\n\n2\n\n\nMIS\n\n\nSPI MISO\n\n\nD3\n\n\n\n\n\n\n3\n\n\nCLK\n\n\nSPI clock\n\n\nD4\n\n\n\n\n\n\n4\n\n\nCS1\n\n\nSPI chip select for ePaper driver IC\n\n\nD5 or any other free pin\n\n\n\n\n\n\n5\n\n\nRST\n\n\nDigital pin to reset driver IC UC8156\n\n\nA0 or any other free pin\n\n\n\n\n\n\n6\n\n\nBSY\n\n\nDigital pin to sense activity state of driver IC UC8156\n\n\nA1 or any other free pin\n\n\n\n\n\n\n7\n\n\n3V3\n\n\nRegulated 3.3V power supply\n\n\n3V3\n\n\n\n\n\n\n8\n\n\nGND\n\n\nGround\n\n\nGND\n\n\n\n\n\n\n9\n\n\n-\n\n\n(unused)\n\n\n(unused)\n\n\n\n\n\n\n10\n\n\nCS2\n\n\nSPI chip select for accelerometer IC\n\n\nD0 or any other free pin\n\n\n\n\n\n\n11\n\n\nIN2\n\n\nInterrupt line #2, e.g. for tap sensing\n\n\nA7 or any other free pin\n\n\n\n\n\n\n12\n\n\nIN1\n\n\nInterrupt line #1, e.g. for wake-up of deep sleeping MCU\n\n\nA7\n\n\n\n\n\n\n\n\nYou can wire-up the two remaining pins called IN1 and IN2 later-on. They are required if you want to wake-up your MCU from deep-sleeping, if for example an motion is detected and/or for sensing finger taps on the screen.\n\n\nHardware hookup\n\n\nNow it\u2019s time to wire it up! In this section we\u2019ll go over the hookup, based on an Particle Photon. We\u2019ll be using Particle\u2019s hardware SPI pins in order to achieve the fastest data transfer speed. That means we\u2019ll need to use pins for SPI connection as described in the table above. The other pins \u2013 RST, BSY, CS1/CS2 and IN1/IN2 \u2013 can be connected to any available digital pin on the Photon.\n\n\nHere\u2019s the example hookup:\n\n\n\n\nUsing the Adafruit GFX Library\n\n\nNow that we have wired-up the Paperino breakout board with the MCU, it\u2019s time to get started writing your own application! Before you get started, here\u2019s a quick overview of the \nPL_microEPD\n library.\n\n\nAt the top of your code, you\u2019ll need to include the Adafruit GFX library together with a library supporting additional fonts (thanks! to Paul Kourany). Finally, you should add the library \nPL_microEPD\n which takes care of the communication to the ePaper display in the background. \n\n\n#include \"Adafruit_mfGFX.h\"\n#include \"fonts.h\"\n#include \"PL_microEPD.h\"\n\n\n\nAfter you have included the library, you can create an object \ndisplay\n in the global variable area of your code. Now its also time to define the pin mapping:\n\n\n#define EPD_RST     A0      //Reset pin, used to restart the driver IC\n#define EPD_BUSY    A1      //Busy pin, used to sense the activity state of the driver IC\n#define EPD_CS      D5      //Chip select pin, used to select the EPD driver IC\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);\n\n\n\nIn the example above we\u2019ve called our \nPL_MicroEPD\n object \ndisplay\n, but you can call it anything you\u2019d like. You can even create more than one, if you have more displays connected to your MCU.\n\n\nThe last step to the Paperino setup should occur in the setup() function. Stick a \ndisplay.begin()\n function in there, which will initialise the display and update all sorts of behind-the-scenes settings for you.\n\n\nsetup() {\n    display.begin();        //Configure Paperino and all of it\u2019s pins\n}\n\n\n\nFirst Example: Hello World!\n\n\nNow we are ready to let the display blink! You can use the \nprint()\n command to write your first text in the screen buffer:\n\n\ndisplay.print(\u201cHello World!\u201d);      //Writes the text \u201cHello World!\u201d into the image buffer\ndisplay.updateFull();               //Refreshing display with the content of the image buffer\n\n\n\nThe command \nupdateFull()\n actually triggers the ePaper refresh, displaying the content of the image buffer finally. That\u2019s it! To summarise everything, you can now see the complete code here:\n\n\n//PAPERINO: Hello World example for the Paperino Micro ePaper breakoutboard\n\n#include \"Adafruit_mfGFX.h\"\n#include \"PLD_tinyEPD.h\"\n#include \"fonts.h\"\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      D5\n\nPL_tinyEPD display(EPD_CS, EPD_RST, EPD_BUSY);\n\nvoid setup() {\n    SPI1.begin();\n    SPI1.setBitOrder(MSBFIRST);                 \n    SPI1.setDataMode(SPI_MODE0); \n    SPI1.setClockDivider(SPI_CLOCK_DIV4);\n    display.begin(true);\n    display.print(\u201cHello World!\u201d);\n    display.updateFull();\n}\n\nvoid loop() {\n    }\n\n\n\nThat was easy, right? If you want to proceed with the setup of the integrated accelerometer let\u2019s continue with the accelerometer hook-up guide.\nIf you are interested in how to write more complex features on the ePaper we suggest starting with the examples section.", 
            "title": "Arduino Web-IDE"
        }, 
        {
            "location": "/hookupEPD/#the-epaper-hookup-guide", 
            "text": "In this tutorial we\u2019ll give you a brief introduction to the Paperino ePaper display and the breakout board, then we\u2019ll jump into example hardware hookups and code. The tutorial is split into the following sections:   Breakout Board  \u2013 To begin, we\u2019ll go over each of the pins on the breakout board and their function.   Hardware hookup  \u2013 In this section we\u2019ll show you how to hook an Arduino up to the display via SPI.  Using the Adafruit Library  \u2013 A quick examination of the Micro ePaper family of function calls.  First Example: Hello World!  \u2013 The first complete example\u2026 let\u2019s make the display blink!   Beside the ePaper breakout board, you\u2019ll need something to control the display. Optimally you\u2019ll want something that has a 3.3V operating voltage. We\u2019ll be using a Particle Photon as an example, which generates and exposes 3V3 on one of the pins.", 
            "title": "The ePaper hookup guide"
        }, 
        {
            "location": "/hookupEPD/#epaper-display", 
            "text": "The ePaper display from Plastic Logic is an eInk-based EPD with 148x70 pixel resolution. It keeps its image content stable without any power, so its perfect for your next connected, ultra-low power project. The display is super thin (less than half a millimeter) and weights just 1.2g!! Actually it\u2019s even bendable, so start thinking now about your next curved product!? ;-)", 
            "title": "ePaper display"
        }, 
        {
            "location": "/hookupEPD/#breakout-board", 
            "text": "The breakout board is the physical interface between the ePaper display and your MCU. It contains a small circuitry to generate the voltages which are needed to switch an ePaper screen. Furthermore it integrates an accelerometer (BMA250) which allows to add additional functionality (like tap detection, portrait/landscape detection, \u2026)   The breakout board provides access to 12 pins. To start with, you\u2019ll only need the first nine pins to make the display work and two further pin to activate the integrated accelerometer. The following table provides an overview of the used pins:     #  Pin  Function  Photon (example)      1  MOS  SPI MOSI  D2    2  MIS  SPI MISO  D3    3  CLK  SPI clock  D4    4  CS1  SPI chip select for ePaper driver IC  D5 or any other free pin    5  RST  Digital pin to reset driver IC UC8156  A0 or any other free pin    6  BSY  Digital pin to sense activity state of driver IC UC8156  A1 or any other free pin    7  3V3  Regulated 3.3V power supply  3V3    8  GND  Ground  GND    9  -  (unused)  (unused)    10  CS2  SPI chip select for accelerometer IC  D0 or any other free pin    11  IN2  Interrupt line #2, e.g. for tap sensing  A7 or any other free pin    12  IN1  Interrupt line #1, e.g. for wake-up of deep sleeping MCU  A7     You can wire-up the two remaining pins called IN1 and IN2 later-on. They are required if you want to wake-up your MCU from deep-sleeping, if for example an motion is detected and/or for sensing finger taps on the screen.", 
            "title": "Breakout Board"
        }, 
        {
            "location": "/hookupEPD/#hardware-hookup", 
            "text": "Now it\u2019s time to wire it up! In this section we\u2019ll go over the hookup, based on an Particle Photon. We\u2019ll be using Particle\u2019s hardware SPI pins in order to achieve the fastest data transfer speed. That means we\u2019ll need to use pins for SPI connection as described in the table above. The other pins \u2013 RST, BSY, CS1/CS2 and IN1/IN2 \u2013 can be connected to any available digital pin on the Photon.  Here\u2019s the example hookup:", 
            "title": "Hardware hookup"
        }, 
        {
            "location": "/hookupEPD/#using-the-adafruit-gfx-library", 
            "text": "Now that we have wired-up the Paperino breakout board with the MCU, it\u2019s time to get started writing your own application! Before you get started, here\u2019s a quick overview of the  PL_microEPD  library.  At the top of your code, you\u2019ll need to include the Adafruit GFX library together with a library supporting additional fonts (thanks! to Paul Kourany). Finally, you should add the library  PL_microEPD  which takes care of the communication to the ePaper display in the background.   #include \"Adafruit_mfGFX.h\"\n#include \"fonts.h\"\n#include \"PL_microEPD.h\"  After you have included the library, you can create an object  display  in the global variable area of your code. Now its also time to define the pin mapping:  #define EPD_RST     A0      //Reset pin, used to restart the driver IC\n#define EPD_BUSY    A1      //Busy pin, used to sense the activity state of the driver IC\n#define EPD_CS      D5      //Chip select pin, used to select the EPD driver IC\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  In the example above we\u2019ve called our  PL_MicroEPD  object  display , but you can call it anything you\u2019d like. You can even create more than one, if you have more displays connected to your MCU.  The last step to the Paperino setup should occur in the setup() function. Stick a  display.begin()  function in there, which will initialise the display and update all sorts of behind-the-scenes settings for you.  setup() {\n    display.begin();        //Configure Paperino and all of it\u2019s pins\n}", 
            "title": "Using the Adafruit GFX Library"
        }, 
        {
            "location": "/hookupEPD/#first-example-hello-world", 
            "text": "Now we are ready to let the display blink! You can use the  print()  command to write your first text in the screen buffer:  display.print(\u201cHello World!\u201d);      //Writes the text \u201cHello World!\u201d into the image buffer\ndisplay.updateFull();               //Refreshing display with the content of the image buffer  The command  updateFull()  actually triggers the ePaper refresh, displaying the content of the image buffer finally. That\u2019s it! To summarise everything, you can now see the complete code here:  //PAPERINO: Hello World example for the Paperino Micro ePaper breakoutboard\n\n#include \"Adafruit_mfGFX.h\"\n#include \"PLD_tinyEPD.h\"\n#include \"fonts.h\"\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      D5\n\nPL_tinyEPD display(EPD_CS, EPD_RST, EPD_BUSY);\n\nvoid setup() {\n    SPI1.begin();\n    SPI1.setBitOrder(MSBFIRST);                 \n    SPI1.setDataMode(SPI_MODE0); \n    SPI1.setClockDivider(SPI_CLOCK_DIV4);\n    display.begin(true);\n    display.print(\u201cHello World!\u201d);\n    display.updateFull();\n}\n\nvoid loop() {\n    }  That was easy, right? If you want to proceed with the setup of the integrated accelerometer let\u2019s continue with the accelerometer hook-up guide.\nIf you are interested in how to write more complex features on the ePaper we suggest starting with the examples section.", 
            "title": "First Example: Hello World!"
        }, 
        {
            "location": "/hookupEPD/", 
            "text": "The ePaper hookup guide\n\n\nIn this tutorial we\u2019ll give you a brief introduction to the Paperino ePaper display and the breakout board, then we\u2019ll jump into example hardware hookups and code. The tutorial is split into the following sections:\n\n\n\n\nBreakout Board\n \u2013 To begin, we\u2019ll go over each of the pins on the breakout board and their function. \n\n\nHardware hookup\n \u2013 In this section we\u2019ll show you how to hook an Arduino up to the display via SPI.\n\n\nUsing the Adafruit Library\n \u2013 A quick examination of the Micro ePaper family of function calls.\n\n\nFirst Example: Hello World!\n \u2013 The first complete example\u2026 let\u2019s make the display blink!\n\n\n\n\nBeside the ePaper breakout board, you\u2019ll need something to control the display. Optimally you\u2019ll want something that has a 3.3V operating voltage. We\u2019ll be using a Particle Photon as an example, which generates and exposes 3V3 on one of the pins.\n\n\nePaper display\n\n\nThe ePaper display from Plastic Logic is an eInk-based EPD with 148x70 pixel resolution. It keeps its image content stable without any power, so its perfect for your next connected, ultra-low power project. The display is super thin (less than half a millimeter) and weights just 1.2g!! Actually it\u2019s even bendable, so start thinking now about your next curved product!? ;-)\n\n\n\n\nBreakout Board\n\n\nThe breakout board is the physical interface between the ePaper display and your MCU. It contains a small circuitry to generate the voltages which are needed to switch an ePaper screen. Furthermore it integrates an accelerometer (BMA250) which allows to add additional functionality (like tap detection, portrait/landscape detection, \u2026)\n\n\n\n\nThe breakout board provides access to 12 pins. To start with, you\u2019ll only need the first nine pins to make the display work and two further pin to activate the integrated accelerometer. The following table provides an overview of the used pins:\n\n\n\n\n\n\n\n\n#\n\n\nPin\n\n\nFunction\n\n\nPhoton (example)\n\n\n\n\n\n\n\n\n\n\n1\n\n\nMOS\n\n\nSPI MOSI\n\n\nD2\n\n\n\n\n\n\n2\n\n\nMIS\n\n\nSPI MISO\n\n\nD3\n\n\n\n\n\n\n3\n\n\nCLK\n\n\nSPI clock\n\n\nD4\n\n\n\n\n\n\n4\n\n\nCS1\n\n\nSPI chip select for ePaper driver IC\n\n\nD5 or any other free pin\n\n\n\n\n\n\n5\n\n\nRST\n\n\nDigital pin to reset driver IC UC8156\n\n\nA0 or any other free pin\n\n\n\n\n\n\n6\n\n\nBSY\n\n\nDigital pin to sense activity state of driver IC UC8156\n\n\nA1 or any other free pin\n\n\n\n\n\n\n7\n\n\n3V3\n\n\nRegulated 3.3V power supply\n\n\n3V3\n\n\n\n\n\n\n8\n\n\nGND\n\n\nGround\n\n\nGND\n\n\n\n\n\n\n9\n\n\n-\n\n\n(unused)\n\n\n(unused)\n\n\n\n\n\n\n10\n\n\nCS2\n\n\nSPI chip select for accelerometer IC\n\n\nD0 or any other free pin\n\n\n\n\n\n\n11\n\n\nIN2\n\n\nInterrupt line #2, e.g. for tap sensing\n\n\nA7 or any other free pin\n\n\n\n\n\n\n12\n\n\nIN1\n\n\nInterrupt line #1, e.g. for wake-up of deep sleeping MCU\n\n\nA7\n\n\n\n\n\n\n\n\nYou can wire-up the two remaining pins called IN1 and IN2 later-on. They are required if you want to wake-up your MCU from deep-sleeping, if for example an motion is detected and/or for sensing finger taps on the screen.\n\n\nHardware hookup\n\n\nNow it\u2019s time to wire it up! In this section we\u2019ll go over the hookup, based on an Particle Photon. We\u2019ll be using Particle\u2019s hardware SPI pins in order to achieve the fastest data transfer speed. That means we\u2019ll need to use pins for SPI connection as described in the table above. The other pins \u2013 RST, BSY, CS1/CS2 and IN1/IN2 \u2013 can be connected to any available digital pin on the Photon.\n\n\nHere\u2019s the example hookup:\n\n\n\n\nUsing the Adafruit GFX Library\n\n\nNow that we have wired-up the Paperino breakout board with the MCU, it\u2019s time to get started writing your own application! Before you get started, here\u2019s a quick overview of the \nPL_microEPD\n library.\n\n\nAt the top of your code, you\u2019ll need to include the Adafruit GFX library together with a library supporting additional fonts (thanks! to Paul Kourany). Finally, you should add the library \nPL_microEPD\n which takes care of the communication to the ePaper display in the background. \n\n\n#include \"Adafruit_mfGFX.h\"\n#include \"fonts.h\"\n#include \"PL_microEPD.h\"\n\n\n\nAfter you have included the library, you can create an object \ndisplay\n in the global variable area of your code. Now its also time to define the pin mapping:\n\n\n#define EPD_RST     A0      //Reset pin, used to restart the driver IC\n#define EPD_BUSY    A1      //Busy pin, used to sense the activity state of the driver IC\n#define EPD_CS      D5      //Chip select pin, used to select the EPD driver IC\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);\n\n\n\nIn the example above we\u2019ve called our \nPL_MicroEPD\n object \ndisplay\n, but you can call it anything you\u2019d like. You can even create more than one, if you have more displays connected to your MCU.\n\n\nThe last step to the Paperino setup should occur in the setup() function. Stick a \ndisplay.begin()\n function in there, which will initialise the display and update all sorts of behind-the-scenes settings for you.\n\n\nsetup() {\n    display.begin();        //Configure Paperino and all of it\u2019s pins\n}\n\n\n\nFirst Example: Hello World!\n\n\nNow we are ready to let the display blink! You can use the \nprint()\n command to write your first text in the screen buffer:\n\n\ndisplay.print(\u201cHello World!\u201d);      //Writes the text \u201cHello World!\u201d into the image buffer\ndisplay.updateFull();               //Refreshing display with the content of the image buffer\n\n\n\nThe command \nupdateFull()\n actually triggers the ePaper refresh, displaying the content of the image buffer finally. That\u2019s it! To summarise everything, you can now see the complete code here:\n\n\n//PAPERINO: Hello World example for the Paperino Micro ePaper breakoutboard\n\n#include \"Adafruit_mfGFX.h\"\n#include \"PLD_tinyEPD.h\"\n#include \"fonts.h\"\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      D5\n\nPL_tinyEPD display(EPD_CS, EPD_RST, EPD_BUSY);\n\nvoid setup() {\n    SPI1.begin();\n    SPI1.setBitOrder(MSBFIRST);                 \n    SPI1.setDataMode(SPI_MODE0); \n    SPI1.setClockDivider(SPI_CLOCK_DIV4);\n    display.begin(true);\n    display.print(\u201cHello World!\u201d);\n    display.updateFull();\n}\n\nvoid loop() {\n    }\n\n\n\nThat was easy, right? If you want to proceed with the setup of the integrated accelerometer let\u2019s continue with the accelerometer hook-up guide.\nIf you are interested in how to write more complex features on the ePaper we suggest starting with the examples section.", 
            "title": "Arduino IDE"
        }, 
        {
            "location": "/hookupEPD/#the-epaper-hookup-guide", 
            "text": "In this tutorial we\u2019ll give you a brief introduction to the Paperino ePaper display and the breakout board, then we\u2019ll jump into example hardware hookups and code. The tutorial is split into the following sections:   Breakout Board  \u2013 To begin, we\u2019ll go over each of the pins on the breakout board and their function.   Hardware hookup  \u2013 In this section we\u2019ll show you how to hook an Arduino up to the display via SPI.  Using the Adafruit Library  \u2013 A quick examination of the Micro ePaper family of function calls.  First Example: Hello World!  \u2013 The first complete example\u2026 let\u2019s make the display blink!   Beside the ePaper breakout board, you\u2019ll need something to control the display. Optimally you\u2019ll want something that has a 3.3V operating voltage. We\u2019ll be using a Particle Photon as an example, which generates and exposes 3V3 on one of the pins.", 
            "title": "The ePaper hookup guide"
        }, 
        {
            "location": "/hookupEPD/#epaper-display", 
            "text": "The ePaper display from Plastic Logic is an eInk-based EPD with 148x70 pixel resolution. It keeps its image content stable without any power, so its perfect for your next connected, ultra-low power project. The display is super thin (less than half a millimeter) and weights just 1.2g!! Actually it\u2019s even bendable, so start thinking now about your next curved product!? ;-)", 
            "title": "ePaper display"
        }, 
        {
            "location": "/hookupEPD/#breakout-board", 
            "text": "The breakout board is the physical interface between the ePaper display and your MCU. It contains a small circuitry to generate the voltages which are needed to switch an ePaper screen. Furthermore it integrates an accelerometer (BMA250) which allows to add additional functionality (like tap detection, portrait/landscape detection, \u2026)   The breakout board provides access to 12 pins. To start with, you\u2019ll only need the first nine pins to make the display work and two further pin to activate the integrated accelerometer. The following table provides an overview of the used pins:     #  Pin  Function  Photon (example)      1  MOS  SPI MOSI  D2    2  MIS  SPI MISO  D3    3  CLK  SPI clock  D4    4  CS1  SPI chip select for ePaper driver IC  D5 or any other free pin    5  RST  Digital pin to reset driver IC UC8156  A0 or any other free pin    6  BSY  Digital pin to sense activity state of driver IC UC8156  A1 or any other free pin    7  3V3  Regulated 3.3V power supply  3V3    8  GND  Ground  GND    9  -  (unused)  (unused)    10  CS2  SPI chip select for accelerometer IC  D0 or any other free pin    11  IN2  Interrupt line #2, e.g. for tap sensing  A7 or any other free pin    12  IN1  Interrupt line #1, e.g. for wake-up of deep sleeping MCU  A7     You can wire-up the two remaining pins called IN1 and IN2 later-on. They are required if you want to wake-up your MCU from deep-sleeping, if for example an motion is detected and/or for sensing finger taps on the screen.", 
            "title": "Breakout Board"
        }, 
        {
            "location": "/hookupEPD/#hardware-hookup", 
            "text": "Now it\u2019s time to wire it up! In this section we\u2019ll go over the hookup, based on an Particle Photon. We\u2019ll be using Particle\u2019s hardware SPI pins in order to achieve the fastest data transfer speed. That means we\u2019ll need to use pins for SPI connection as described in the table above. The other pins \u2013 RST, BSY, CS1/CS2 and IN1/IN2 \u2013 can be connected to any available digital pin on the Photon.  Here\u2019s the example hookup:", 
            "title": "Hardware hookup"
        }, 
        {
            "location": "/hookupEPD/#using-the-adafruit-gfx-library", 
            "text": "Now that we have wired-up the Paperino breakout board with the MCU, it\u2019s time to get started writing your own application! Before you get started, here\u2019s a quick overview of the  PL_microEPD  library.  At the top of your code, you\u2019ll need to include the Adafruit GFX library together with a library supporting additional fonts (thanks! to Paul Kourany). Finally, you should add the library  PL_microEPD  which takes care of the communication to the ePaper display in the background.   #include \"Adafruit_mfGFX.h\"\n#include \"fonts.h\"\n#include \"PL_microEPD.h\"  After you have included the library, you can create an object  display  in the global variable area of your code. Now its also time to define the pin mapping:  #define EPD_RST     A0      //Reset pin, used to restart the driver IC\n#define EPD_BUSY    A1      //Busy pin, used to sense the activity state of the driver IC\n#define EPD_CS      D5      //Chip select pin, used to select the EPD driver IC\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  In the example above we\u2019ve called our  PL_MicroEPD  object  display , but you can call it anything you\u2019d like. You can even create more than one, if you have more displays connected to your MCU.  The last step to the Paperino setup should occur in the setup() function. Stick a  display.begin()  function in there, which will initialise the display and update all sorts of behind-the-scenes settings for you.  setup() {\n    display.begin();        //Configure Paperino and all of it\u2019s pins\n}", 
            "title": "Using the Adafruit GFX Library"
        }, 
        {
            "location": "/hookupEPD/#first-example-hello-world", 
            "text": "Now we are ready to let the display blink! You can use the  print()  command to write your first text in the screen buffer:  display.print(\u201cHello World!\u201d);      //Writes the text \u201cHello World!\u201d into the image buffer\ndisplay.updateFull();               //Refreshing display with the content of the image buffer  The command  updateFull()  actually triggers the ePaper refresh, displaying the content of the image buffer finally. That\u2019s it! To summarise everything, you can now see the complete code here:  //PAPERINO: Hello World example for the Paperino Micro ePaper breakoutboard\n\n#include \"Adafruit_mfGFX.h\"\n#include \"PLD_tinyEPD.h\"\n#include \"fonts.h\"\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      D5\n\nPL_tinyEPD display(EPD_CS, EPD_RST, EPD_BUSY);\n\nvoid setup() {\n    SPI1.begin();\n    SPI1.setBitOrder(MSBFIRST);                 \n    SPI1.setDataMode(SPI_MODE0); \n    SPI1.setClockDivider(SPI_CLOCK_DIV4);\n    display.begin(true);\n    display.print(\u201cHello World!\u201d);\n    display.updateFull();\n}\n\nvoid loop() {\n    }  That was easy, right? If you want to proceed with the setup of the integrated accelerometer let\u2019s continue with the accelerometer hook-up guide.\nIf you are interested in how to write more complex features on the ePaper we suggest starting with the examples section.", 
            "title": "First Example: Hello World!"
        }, 
        {
            "location": "/exampleHelloWorld/", 
            "text": "Example 1: Hello World!\n\n\nIn this first section we show you how to initialize the ePaper display and write \u201cHello World!\u201d on the screen. It is the shortest possible demo, you will see it\u2019s really simple!\n\n\nDemo\n\n\n\n\nSketch\n\n\nNow let\u2019s have a look at the code: The first lines in the setup section are required to define the SPI settings needed to communicate with the display IC. Before you can talk to your display, the function \nbegin()\n needs to be called once in the \nsetup()\n loop.  This initialises your ePaper screen and resets it to a solid white background. To write text, the function \nprint()\n or \nprintln()\n can be used. Call \nupdate()\n to actually trigger an update. This refresh the screen with the content of the previously filled image buffer. The running demo should look like the video in the section above.\n\n\n#include \nAdafruit_GFX.h\n\n#include \nPL_microEPD.h\n\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  \n\nvoid setup() {  \n    SPI.begin();                    // SPI-Bus initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();                // Paperino ePaper initialisation and refresh screen \n    display.println(\nHello World!\n);// Write message into memory buffer\n    display.update();               // Trigger a full image update\n}\n\nvoid loop() {              \n}\n\n\n\n\nAre you interested in printing more complicated things on the screen? Then let\u2019s proceed with the following \nGFX example\n, which shows you how to draw text in different sizes and how to draw graphic elements like lines, circles \n rectangles.", 
            "title": "Hello World!"
        }, 
        {
            "location": "/exampleHelloWorld/#example-1-hello-world", 
            "text": "In this first section we show you how to initialize the ePaper display and write \u201cHello World!\u201d on the screen. It is the shortest possible demo, you will see it\u2019s really simple!", 
            "title": "Example 1: Hello World!"
        }, 
        {
            "location": "/exampleHelloWorld/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/exampleHelloWorld/#sketch", 
            "text": "Now let\u2019s have a look at the code: The first lines in the setup section are required to define the SPI settings needed to communicate with the display IC. Before you can talk to your display, the function  begin()  needs to be called once in the  setup()  loop.  This initialises your ePaper screen and resets it to a solid white background. To write text, the function  print()  or  println()  can be used. Call  update()  to actually trigger an update. This refresh the screen with the content of the previously filled image buffer. The running demo should look like the video in the section above.  #include  Adafruit_GFX.h \n#include  PL_microEPD.h \n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  \n\nvoid setup() {  \n    SPI.begin();                    // SPI-Bus initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();                // Paperino ePaper initialisation and refresh screen \n    display.println( Hello World! );// Write message into memory buffer\n    display.update();               // Trigger a full image update\n}\n\nvoid loop() {              \n}  Are you interested in printing more complicated things on the screen? Then let\u2019s proceed with the following  GFX example , which shows you how to draw text in different sizes and how to draw graphic elements like lines, circles   rectangles.", 
            "title": "Sketch"
        }, 
        {
            "location": "/exampleGFXdemo/", 
            "text": "Example 2: GFX Graphics demo\n\n\nIn the \nprevious example\n we learned how to initialise the ePaper screen and write \u201cHello World!\u201d on it. Now let\u2019s try some more complicated features! In this chapter we will learn how to change the size and the position of the text and how to change the text font. Afterwards we will see how easy it is to draw some graphic elements on the display. The last section contains the sketch for an executable demo to try out by yourself.\n\n\nCharacters and Text\n\n\nThe \nAdafruit GFX Graphics library\n provides many easy to use functions to write characters and text on the screen. Typical functions are: \ndrawChar()\n, \nsetCursor()\n, \nsetTextColor()\n, \nsetTextSize()\n, \nsetFont()\n, \nsetTextWrap()\n. A good starting point for more detailed syntax and information is \nthis learning site\n.\n\n\nGraphics\n\n\nFor drawing graphics like circles, rectangles or triangles, the GFX library provides this typical functions: \ndrawPixel()\n, \ndrawLine()\n, \ndrawRect()\n, \nfillRect()\n, \ndrawCircle()\n, \nfillCircle()\n, \ndrawRoundRect()\n, \nfillRoundRect()\n, \ndrawTriangle()\n, \ndrawfillTriangle()\n. Again, please head over to Adafruits \nlearning site\n for more information.\n\n\nDemo\n\n\n\n\nSketch\n\n\nThe following sketch starts with a loop which draws a sequence of ASCII characters on the screen using the function \ndrawChar()\n. The next section shows how to set the font size based on the function \nsetTextSize()\n. Inverting of the screen content can be done with \ninvert()\n. The last part of the sketch shows how to draw some rectangles, filled rectangles and circles. \n\n\n#include \nAdafruit_GFX.h\n\n#include \nPL_microEPD.h\n\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY); \nint i=0;\n\nvoid setup() {\n    SPI.begin();                            // SPI initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();                        // Paperino ePaper initialisation and refresh screen \n    for (int y=0; y \n 6; y++) {\n        for (int x=0; x \n 26; x++) {\n            i=i+1;                          // Draw some ASCII characters\n            display.drawChar(1+x*7,1+y*11,i,0,3,1);\n        }   \n    }\n    display.update();                       // Trigger a full image update\n    delay(5000);\n\n    display.clear();                        // Clear the image buffer\n    display.setCursor(1,1);                 // Set Cursor start position \n    display.println(\nSize1\n);\n    display.setTextSize(2);                 // Change text size\n    display.println(\nSize2\n);\n    display.setTextSize(3);\n    display.println(\nSize3\n);\n    display.setCursor(100,5);\n    display.setTextSize(9);\n    display.println(\n9\n);\n    display.update();                       // Trigger a full image update\n    delay(5000);\n\n    display.invert();                       // Invert the display content\n    display.update();\n    delay(5000);\n\n    display.clear();\n    display.drawRect(5, 5, 50, 50, EPD_BLACK);          // Draw a rectangle\n    display.fillRect(40,40,25,25, EPD_BLACK);        // Draw a filled rectangle \n    display.drawCircle(100, 35, 30, EPD_BLACK);        // Draw a circle\n    display.drawCircle(100, 35, 15, EPD_BLACK);\n    display.drawCircle(100, 35, 8, EPD_BLACK);\n    display.drawCircle(100, 35, 4, EPD_BLACK);\n    display.update();\n    delay(5000);\n\n    display.clear();\n    display.setTextSize(2);\n    display.setCursor(5, 20);\n    display.println(\nHello\n);\n    display.setCursor(5, 36);\n    display.println(\nWorld!\n);\n    display.drawCircle(170, 36, 40, EPD_BLACK);\n    display.drawCircle(170, 36, 45, EPD_BLACK);\n    display.drawCircle(170, 36, 50, EPD_BLACK);\n    display.drawCircle(170, 36, 55, EPD_BLACK);\n    display.drawCircle(170, 36, 70, EPD_BLACK);\n    display.drawCircle(170, 36, 75, EPD_BLACK);\n    display.drawCircle(0, 36, 135, EPD_BLACK);\n    display.drawCircle(0, 36, 120, EPD_BLACK);\n    display.drawCircle(0, 36, 75, EPD_BLACK);\n    display.invert();\n    display.update();\n}\n\nvoid loop() {\n}\n\n\n\n\nSo far we used black as primary color for drawing the graphic elements. The next example will show you how to change the color and how to add the intermediate colours lightgray and darkgray. Interested? Then let\u2019s proceed \nhere\n.", 
            "title": "GFX demo"
        }, 
        {
            "location": "/exampleGFXdemo/#example-2-gfx-graphics-demo", 
            "text": "In the  previous example  we learned how to initialise the ePaper screen and write \u201cHello World!\u201d on it. Now let\u2019s try some more complicated features! In this chapter we will learn how to change the size and the position of the text and how to change the text font. Afterwards we will see how easy it is to draw some graphic elements on the display. The last section contains the sketch for an executable demo to try out by yourself.", 
            "title": "Example 2: GFX Graphics demo"
        }, 
        {
            "location": "/exampleGFXdemo/#characters-and-text", 
            "text": "The  Adafruit GFX Graphics library  provides many easy to use functions to write characters and text on the screen. Typical functions are:  drawChar() ,  setCursor() ,  setTextColor() ,  setTextSize() ,  setFont() ,  setTextWrap() . A good starting point for more detailed syntax and information is  this learning site .", 
            "title": "Characters and Text"
        }, 
        {
            "location": "/exampleGFXdemo/#graphics", 
            "text": "For drawing graphics like circles, rectangles or triangles, the GFX library provides this typical functions:  drawPixel() ,  drawLine() ,  drawRect() ,  fillRect() ,  drawCircle() ,  fillCircle() ,  drawRoundRect() ,  fillRoundRect() ,  drawTriangle() ,  drawfillTriangle() . Again, please head over to Adafruits  learning site  for more information.", 
            "title": "Graphics"
        }, 
        {
            "location": "/exampleGFXdemo/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/exampleGFXdemo/#sketch", 
            "text": "The following sketch starts with a loop which draws a sequence of ASCII characters on the screen using the function  drawChar() . The next section shows how to set the font size based on the function  setTextSize() . Inverting of the screen content can be done with  invert() . The last part of the sketch shows how to draw some rectangles, filled rectangles and circles.   #include  Adafruit_GFX.h \n#include  PL_microEPD.h \n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY); \nint i=0;\n\nvoid setup() {\n    SPI.begin();                            // SPI initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();                        // Paperino ePaper initialisation and refresh screen \n    for (int y=0; y   6; y++) {\n        for (int x=0; x   26; x++) {\n            i=i+1;                          // Draw some ASCII characters\n            display.drawChar(1+x*7,1+y*11,i,0,3,1);\n        }   \n    }\n    display.update();                       // Trigger a full image update\n    delay(5000);\n\n    display.clear();                        // Clear the image buffer\n    display.setCursor(1,1);                 // Set Cursor start position \n    display.println( Size1 );\n    display.setTextSize(2);                 // Change text size\n    display.println( Size2 );\n    display.setTextSize(3);\n    display.println( Size3 );\n    display.setCursor(100,5);\n    display.setTextSize(9);\n    display.println( 9 );\n    display.update();                       // Trigger a full image update\n    delay(5000);\n\n    display.invert();                       // Invert the display content\n    display.update();\n    delay(5000);\n\n    display.clear();\n    display.drawRect(5, 5, 50, 50, EPD_BLACK);          // Draw a rectangle\n    display.fillRect(40,40,25,25, EPD_BLACK);        // Draw a filled rectangle \n    display.drawCircle(100, 35, 30, EPD_BLACK);        // Draw a circle\n    display.drawCircle(100, 35, 15, EPD_BLACK);\n    display.drawCircle(100, 35, 8, EPD_BLACK);\n    display.drawCircle(100, 35, 4, EPD_BLACK);\n    display.update();\n    delay(5000);\n\n    display.clear();\n    display.setTextSize(2);\n    display.setCursor(5, 20);\n    display.println( Hello );\n    display.setCursor(5, 36);\n    display.println( World! );\n    display.drawCircle(170, 36, 40, EPD_BLACK);\n    display.drawCircle(170, 36, 45, EPD_BLACK);\n    display.drawCircle(170, 36, 50, EPD_BLACK);\n    display.drawCircle(170, 36, 55, EPD_BLACK);\n    display.drawCircle(170, 36, 70, EPD_BLACK);\n    display.drawCircle(170, 36, 75, EPD_BLACK);\n    display.drawCircle(0, 36, 135, EPD_BLACK);\n    display.drawCircle(0, 36, 120, EPD_BLACK);\n    display.drawCircle(0, 36, 75, EPD_BLACK);\n    display.invert();\n    display.update();\n}\n\nvoid loop() {\n}  So far we used black as primary color for drawing the graphic elements. The next example will show you how to change the color and how to add the intermediate colours lightgray and darkgray. Interested? Then let\u2019s proceed  here .", 
            "title": "Sketch"
        }, 
        {
            "location": "/example4GLs/", 
            "text": "Example 3: 4 Graylevels\n\n\nIn the \nprevious examples\n we always use black as primary color for drawing something on the screen. In this chapter we will see how to change the color and make use of the four supported gray levels: White, Light Gray, Dark Gray and Black.\n\n\nColors\n\n\nThis E-paper library uses the following definitions to set a color \nEPD_WHITE\n, \nEPD_LGRAY\n, \nEPD_DGRAY\n and \nEPD_BLACK\n. They can be used for all graphic elements and for characters and text via the function \nsetTextColor()\n. Please have a look at the following sketch.\n\n\nDemo\n\n\n\n\nSketch\n\n\n#include \nAdafruit_GFX.h\n\n#include \nPL_microEPD.h\n\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);\n\nvoid setup() {\n    SPI.begin();                    // SPI-Bus initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();                // Paperino ePaper initialisation and refresh screen\n\n    display.setCursor(8,28);\n    display.setTextSize(2);\n    display.println(\nGray Levels\n);\n    display.update();\n    delay(2000);\n\n    display.clear();\n    display.setCursor(45,15);\n    display.println(\nBlack\n);\n    display.update();\n    delay(500);\n    display.fillRect(10, 37, 128, 25, EPD_BLACK);   // Color = BLACK\n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.setCursor(19,15);\n    display.println(\nDark Gray\n);\n    display.update();\n    delay(500);\n    display.fillRect(10, 37, 128, 25, EPD_DGRAY);   // Color = DARK GRAY\n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.setCursor(15,15);\n    display.println(\nLight Gray\n);\n    display.update();\n    delay(500);\n    display.fillRect(10, 37, 128, 25, EPD_LGRAY);   // Color = LIGHT GRAY\n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.setCursor(45,15);\n    display.println(\nWhite\n);\n    display.update();\n    delay(500);\n    display.drawRect(10, 37, 128, 25, EPD_BLACK);   \n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.drawRect(9, 21, 130, 30, EPD_BLACK);\n    display.update();\n    display.fillRect(10, 22, 33, 28, EPD_BLACK);\n    display.update(EPD_UPD_PART);\n    display.fillRect(43, 22, 33, 28, EPD_DGRAY);\n    display.update(EPD_UPD_PART);\n    display.fillRect(76, 22, 32, 28, EPD_LGRAY);\n    display.update(EPD_UPD_PART);\n}\n\nvoid loop() {\n}\n\n\n\n\nUpto now, each update refreshed all the pixels no matter they were changing or not. In the next section we will see how to make use of so called partial update modes of the Epaper screen. If you are interested please head over \nhere\n.", 
            "title": "Graylevels"
        }, 
        {
            "location": "/example4GLs/#example-3-4-graylevels", 
            "text": "In the  previous examples  we always use black as primary color for drawing something on the screen. In this chapter we will see how to change the color and make use of the four supported gray levels: White, Light Gray, Dark Gray and Black.", 
            "title": "Example 3: 4 Graylevels"
        }, 
        {
            "location": "/example4GLs/#colors", 
            "text": "This E-paper library uses the following definitions to set a color  EPD_WHITE ,  EPD_LGRAY ,  EPD_DGRAY  and  EPD_BLACK . They can be used for all graphic elements and for characters and text via the function  setTextColor() . Please have a look at the following sketch.", 
            "title": "Colors"
        }, 
        {
            "location": "/example4GLs/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/example4GLs/#sketch", 
            "text": "#include  Adafruit_GFX.h \n#include  PL_microEPD.h \n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);\n\nvoid setup() {\n    SPI.begin();                    // SPI-Bus initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();                // Paperino ePaper initialisation and refresh screen\n\n    display.setCursor(8,28);\n    display.setTextSize(2);\n    display.println( Gray Levels );\n    display.update();\n    delay(2000);\n\n    display.clear();\n    display.setCursor(45,15);\n    display.println( Black );\n    display.update();\n    delay(500);\n    display.fillRect(10, 37, 128, 25, EPD_BLACK);   // Color = BLACK\n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.setCursor(19,15);\n    display.println( Dark Gray );\n    display.update();\n    delay(500);\n    display.fillRect(10, 37, 128, 25, EPD_DGRAY);   // Color = DARK GRAY\n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.setCursor(15,15);\n    display.println( Light Gray );\n    display.update();\n    delay(500);\n    display.fillRect(10, 37, 128, 25, EPD_LGRAY);   // Color = LIGHT GRAY\n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.setCursor(45,15);\n    display.println( White );\n    display.update();\n    delay(500);\n    display.drawRect(10, 37, 128, 25, EPD_BLACK);   \n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.drawRect(9, 21, 130, 30, EPD_BLACK);\n    display.update();\n    display.fillRect(10, 22, 33, 28, EPD_BLACK);\n    display.update(EPD_UPD_PART);\n    display.fillRect(43, 22, 33, 28, EPD_DGRAY);\n    display.update(EPD_UPD_PART);\n    display.fillRect(76, 22, 32, 28, EPD_LGRAY);\n    display.update(EPD_UPD_PART);\n}\n\nvoid loop() {\n}  Upto now, each update refreshed all the pixels no matter they were changing or not. In the next section we will see how to make use of so called partial update modes of the Epaper screen. If you are interested please head over  here .", 
            "title": "Sketch"
        }, 
        {
            "location": "/exampleUpdateMode/", 
            "text": "Example 4: Update Modes\n\n\nIn the previous examples, we learned how to \ninitialise\n the display, how to write different \ngraphics \n text\n and how to use different \ngraylevels\n. Now let\u2019s have a look at three different ways how to update an ePaper screen. \n\n\nUpdate Modes\n\n\nThe E-Paper library defines the following three update modes \nEPD_UPD_FULL\n, \nEPD_UPD_PART\n and \nEPD_MONO\n.\n\nEPD_UPD_FULL\n is set by default, achieves four graylevels, takes about 800ms and refreshes all pixels. This is the update mode having the best image quality. \nEPD_UPD_PART\n is a variant of the previous one but only changing pixels are refreshed. This results in less flickering for the price of a slightly higher pixel to pixel crosstalk. \nEPD_MONO\n is again a variant of the previous update mode but only about 250ms long. This allows slightly faster and more responsive updates for the price of supporting only two graylevels (\nEPD_BLACK\n and \nEPD_WHITE\n). Depending on your application it is recommended to insert a full update \nEPD_UPD_FULL\n after a couple of mono updates to increase the image quality. \n\n\nDemo\n\n\n\n\nSketch\n\n\n#include \nAdafruit_GFX.h\n\n#include \nPL_microEPD.h\n\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY); \n\n\nvoid setup() {\n    SPI.begin();                            // SPI initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n    display.begin();                        // Paperino ePaper initialisation and refresh screen \n\n    display.setTextSize(2);\n    display.println(\nUpdate Modes\n);\n    display.setTextSize(1);\n    display.println(\n-Full Update\n);\n    display.println(\n-Partial Update\n);          \n    display.println(\n-Partial Mono Update\n);          \n    display.update();                       // Triggers a Full update, 4 GL, 800ms\n\n    delay(4000);\n    display.clear();\n    display.setTextSize(2);\n    display.print(\nEPD_UPD_FULL\n);          \n    display.update();                       // Triggers a Full update, 4 GL, 800ms\n    delay(1000);\n    display.setTextSize(1);\n    display.print(\nThis is a \n);\n    display.setTextColor(EPD_WHITE, EPD_BLACK);\n    display.println(\nfull update.\n);\n    display.update();                   \n    delay(1000);\n    display.setTextColor(EPD_BLACK, EPD_WHITE);\n    display.println(\nAll pixels are reset no matter whether they are changing or not.\n);\n    display.update();\n    delay(2000);\n    display.println(\nHm, a bit boring, isn't it...?\n);\n    display.update();\n\n    delay(4000);\n    display.clear();\n    display.setTextSize(2);\n    display.print(\nEPD_UPD_PART\n);                 \n    display.update(EPD_UPD_PART);           // Triggers a Partial update, 4 GL, 800ms\n    delay(1000);\n    display.setTextSize(1);\n    display.print(\nOK! Now you see \n);\n    display.setTextColor(EPD_WHITE, EPD_BLACK);\n    display.print(\npartial updates!\n);\n    display.update(EPD_UPD_PART);                \n    delay(1000);\n    display.setTextColor(EPD_BLACK, EPD_WHITE);\n    display.print(\n Only changing  pixels are updated. \n);\n    display.update(EPD_UPD_PART);\n    delay(1000);\n    display.print(\nThisgenerates less flicker  and results in lower    power consumption. \n);\n    display.update(EPD_UPD_PART);\n\n    delay(4000);\n    display.clear();\n    display.setTextSize(2);\n    display.print(\nEPD_UPD_MONO\n);                 \n    display.update(EPD_UPD_MONO);           // Triggers a Partial Mono update, 2 GL, 250ms\n    delay(1000);\n    display.setTextSize(1);\n    display.setTextColor(EPD_WHITE, EPD_BLACK);\n    display.print(\nMono updates\n);\n    display.setTextColor(EPD_BLACK, EPD_WHITE);\n    display.print(\n allow a bitfaster update rates \n);\n    display.update(EPD_UPD_MONO);                \n    delay(1000);\n    display.print(\n(butsupport only two grey-  levels).\n);\n    display.update(EPD_UPD_MONO);\n\n    delay(1000);\n    display.drawRect(9, 51, 125, 14, 0);\n    display.update(EPD_UPD_MONO);\n    for (int i=1; i\n18; i++) {\n        display.fillRect(6 + 7*i, 53, 5, 10, 0);\n        display.update(EPD_UPD_MONO);\n    }\n}\n\nvoid loop() {\n}\n\n\n\n\nCongratulation! You now learned the basics of running an ePaper screen. Interested in more? In the next examples we learn how to make use of the integrated accelerometer as a cheap touch emulator.", 
            "title": "Update Modes"
        }, 
        {
            "location": "/exampleUpdateMode/#example-4-update-modes", 
            "text": "In the previous examples, we learned how to  initialise  the display, how to write different  graphics   text  and how to use different  graylevels . Now let\u2019s have a look at three different ways how to update an ePaper screen.", 
            "title": "Example 4: Update Modes"
        }, 
        {
            "location": "/exampleUpdateMode/#update-modes", 
            "text": "The E-Paper library defines the following three update modes  EPD_UPD_FULL ,  EPD_UPD_PART  and  EPD_MONO . EPD_UPD_FULL  is set by default, achieves four graylevels, takes about 800ms and refreshes all pixels. This is the update mode having the best image quality.  EPD_UPD_PART  is a variant of the previous one but only changing pixels are refreshed. This results in less flickering for the price of a slightly higher pixel to pixel crosstalk.  EPD_MONO  is again a variant of the previous update mode but only about 250ms long. This allows slightly faster and more responsive updates for the price of supporting only two graylevels ( EPD_BLACK  and  EPD_WHITE ). Depending on your application it is recommended to insert a full update  EPD_UPD_FULL  after a couple of mono updates to increase the image quality.", 
            "title": "Update Modes"
        }, 
        {
            "location": "/exampleUpdateMode/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/exampleUpdateMode/#sketch", 
            "text": "#include  Adafruit_GFX.h \n#include  PL_microEPD.h \n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY); \n\n\nvoid setup() {\n    SPI.begin();                            // SPI initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n    display.begin();                        // Paperino ePaper initialisation and refresh screen \n\n    display.setTextSize(2);\n    display.println( Update Modes );\n    display.setTextSize(1);\n    display.println( -Full Update );\n    display.println( -Partial Update );          \n    display.println( -Partial Mono Update );          \n    display.update();                       // Triggers a Full update, 4 GL, 800ms\n\n    delay(4000);\n    display.clear();\n    display.setTextSize(2);\n    display.print( EPD_UPD_FULL );          \n    display.update();                       // Triggers a Full update, 4 GL, 800ms\n    delay(1000);\n    display.setTextSize(1);\n    display.print( This is a  );\n    display.setTextColor(EPD_WHITE, EPD_BLACK);\n    display.println( full update. );\n    display.update();                   \n    delay(1000);\n    display.setTextColor(EPD_BLACK, EPD_WHITE);\n    display.println( All pixels are reset no matter whether they are changing or not. );\n    display.update();\n    delay(2000);\n    display.println( Hm, a bit boring, isn't it...? );\n    display.update();\n\n    delay(4000);\n    display.clear();\n    display.setTextSize(2);\n    display.print( EPD_UPD_PART );                 \n    display.update(EPD_UPD_PART);           // Triggers a Partial update, 4 GL, 800ms\n    delay(1000);\n    display.setTextSize(1);\n    display.print( OK! Now you see  );\n    display.setTextColor(EPD_WHITE, EPD_BLACK);\n    display.print( partial updates! );\n    display.update(EPD_UPD_PART);                \n    delay(1000);\n    display.setTextColor(EPD_BLACK, EPD_WHITE);\n    display.print(  Only changing  pixels are updated.  );\n    display.update(EPD_UPD_PART);\n    delay(1000);\n    display.print( Thisgenerates less flicker  and results in lower    power consumption.  );\n    display.update(EPD_UPD_PART);\n\n    delay(4000);\n    display.clear();\n    display.setTextSize(2);\n    display.print( EPD_UPD_MONO );                 \n    display.update(EPD_UPD_MONO);           // Triggers a Partial Mono update, 2 GL, 250ms\n    delay(1000);\n    display.setTextSize(1);\n    display.setTextColor(EPD_WHITE, EPD_BLACK);\n    display.print( Mono updates );\n    display.setTextColor(EPD_BLACK, EPD_WHITE);\n    display.print(  allow a bitfaster update rates  );\n    display.update(EPD_UPD_MONO);                \n    delay(1000);\n    display.print( (butsupport only two grey-  levels). );\n    display.update(EPD_UPD_MONO);\n\n    delay(1000);\n    display.drawRect(9, 51, 125, 14, 0);\n    display.update(EPD_UPD_MONO);\n    for (int i=1; i 18; i++) {\n        display.fillRect(6 + 7*i, 53, 5, 10, 0);\n        display.update(EPD_UPD_MONO);\n    }\n}\n\nvoid loop() {\n}  Congratulation! You now learned the basics of running an ePaper screen. Interested in more? In the next examples we learn how to make use of the integrated accelerometer as a cheap touch emulator.", 
            "title": "Sketch"
        }, 
        {
            "location": "/exampleTapCounter/", 
            "text": "Example 5: Tap Counter\n\n\nAfter having learned the basics about driving an E-paper screen let\u2019s have a look at the integrated accelerometer. One of its nice features is the supported Tap detection. This allows you to trigger an interrupt, setting a GPIO pin HIGH which can be detected by your micro controller. This setup allows you to add a cheap feedback loop to your projects by implementing a kind of single touch emulation. \n\n\nAccelerometer: Tap detection\n\n\nThe following sketch shows you who to detect a finger tap and increase a counter based on the users input.\n\n\nDemo\n\n\n\n\nSketch\n\n\nSYSTEM_MODE(SEMI_AUTOMATIC);\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n#define ACC_CS      D0\n\n#include \nAdafruit_GFX.h\n\n#include \nPL_microEPD.h\n\n#include \nBO_BMA250E.h\n\n\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  \nBO_BMA250   accel(ACC_CS);\nint         i       = 0;\nbool        status  = false;     //0 = stopped, 1 = running\n\nvoid setup() {\n    pinMode(WKP, INPUT);\n\n    SPI.begin();\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();\n    display.setTextSize(6);\n    display.setCursor(0,4);\n    display.print(i);\n    display.drawCircle(170, 36, 40, EPD_LGRAY);\n    display.drawCircle(170, 36, 45, EPD_LGRAY);\n    display.drawCircle(170, 36, 50, EPD_LGRAY);\n    display.drawCircle(170, 36, 55, EPD_LGRAY);\n    display.drawCircle(170, 36, 70, EPD_LGRAY);\n    display.drawCircle(170, 36, 75, EPD_LGRAY);\n    display.drawCircle(0, 36, 135, EPD_LGRAY);\n    display.drawCircle(0, 36, 120, EPD_LGRAY);\n    display.drawCircle(0, 36, 95, EPD_LGRAY);\n    display.setTextSize(1);\n    display.setCursor(0, 52);\n    display.print(\nPlease tap to increase  the counter!\n);\n    display.update(); \n\n    accel.begin();\n    accel.activateTapOnInt1();\n}\n\nvoid loop() {\n    if (digitalRead(WKP)==HIGH) {\n        status = !status; \n        if (status==true) {\n            i+=1;\n            display.fillRect(0, 4, 70, 43, EPD_WHITE);\n            display.setTextSize(6);\n            display.setCursor(0,4);\n            display.print(i);\n            display.update(EPD_UPD_MONO);\n            status = !status;\n        };\n        delay(1000);\n    };\n}\n\n\n\n\nIn the next example we\u2019ll see how to use the accelerometer interrupt to wake-up a micro controller. This enables us to put the MCU in deep-sleep for most of the times which is a good approach to reduce the overall power consumption.", 
            "title": "Tap Counter"
        }, 
        {
            "location": "/exampleTapCounter/#example-5-tap-counter", 
            "text": "After having learned the basics about driving an E-paper screen let\u2019s have a look at the integrated accelerometer. One of its nice features is the supported Tap detection. This allows you to trigger an interrupt, setting a GPIO pin HIGH which can be detected by your micro controller. This setup allows you to add a cheap feedback loop to your projects by implementing a kind of single touch emulation.", 
            "title": "Example 5: Tap Counter"
        }, 
        {
            "location": "/exampleTapCounter/#accelerometer-tap-detection", 
            "text": "The following sketch shows you who to detect a finger tap and increase a counter based on the users input.", 
            "title": "Accelerometer: Tap detection"
        }, 
        {
            "location": "/exampleTapCounter/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/exampleTapCounter/#sketch", 
            "text": "SYSTEM_MODE(SEMI_AUTOMATIC);\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n#define ACC_CS      D0\n\n#include  Adafruit_GFX.h \n#include  PL_microEPD.h \n#include  BO_BMA250E.h \n\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  \nBO_BMA250   accel(ACC_CS);\nint         i       = 0;\nbool        status  = false;     //0 = stopped, 1 = running\n\nvoid setup() {\n    pinMode(WKP, INPUT);\n\n    SPI.begin();\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();\n    display.setTextSize(6);\n    display.setCursor(0,4);\n    display.print(i);\n    display.drawCircle(170, 36, 40, EPD_LGRAY);\n    display.drawCircle(170, 36, 45, EPD_LGRAY);\n    display.drawCircle(170, 36, 50, EPD_LGRAY);\n    display.drawCircle(170, 36, 55, EPD_LGRAY);\n    display.drawCircle(170, 36, 70, EPD_LGRAY);\n    display.drawCircle(170, 36, 75, EPD_LGRAY);\n    display.drawCircle(0, 36, 135, EPD_LGRAY);\n    display.drawCircle(0, 36, 120, EPD_LGRAY);\n    display.drawCircle(0, 36, 95, EPD_LGRAY);\n    display.setTextSize(1);\n    display.setCursor(0, 52);\n    display.print( Please tap to increase  the counter! );\n    display.update(); \n\n    accel.begin();\n    accel.activateTapOnInt1();\n}\n\nvoid loop() {\n    if (digitalRead(WKP)==HIGH) {\n        status = !status; \n        if (status==true) {\n            i+=1;\n            display.fillRect(0, 4, 70, 43, EPD_WHITE);\n            display.setTextSize(6);\n            display.setCursor(0,4);\n            display.print(i);\n            display.update(EPD_UPD_MONO);\n            status = !status;\n        };\n        delay(1000);\n    };\n}  In the next example we\u2019ll see how to use the accelerometer interrupt to wake-up a micro controller. This enables us to put the MCU in deep-sleep for most of the times which is a good approach to reduce the overall power consumption.", 
            "title": "Sketch"
        }, 
        {
            "location": "/exampleWakeOnTap/", 
            "text": "Example 6: WakeOnTap\n\n\nAfter having learned the basics about driving an E-paper screen let\u2019s have a look at the integrated accelerometer. One of its nice features is the supported Tap detection. This allows you to trigger an interrupt, setting a GPIO pin HIGH which can be detected by your micro controller. This setup allows you to add a cheap feedback loop to your projects by implementing a kind of single touch emulation. \n\n\nAccelerometer: Tap detection\n\n\nThe following sketch shows you who to detect a finger tap and increase a counter based on the users input.\n\n\nDemo\n\n\n\n\nSketch\n\n\nSYSTEM_MODE(SEMI_AUTOMATIC);\nSTARTUP(System.enableFeature(FEATURE_RETAINED_MEMORY));\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n#define ACC_CS      D0\n\n#include \nAdafruit_GFX.h\n\n#include \nPL_microEPD.h\n\n#include \nBO_BMA250E.h\n\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  \nBO_BMA250   accel(ACC_CS);\nretained int i = 0;\n\nvoid setup() {\n    SPI.begin();\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    i+=1;\n    display.begin(false);\n    display.setTextSize(6);\n    display.setCursor(0,4);\n    display.print(i);\n    display.drawCircle(170, 36, 40, EPD_LGRAY);\n    display.drawCircle(170, 36, 45, EPD_LGRAY);\n    display.drawCircle(170, 36, 50, EPD_LGRAY);\n    display.drawCircle(170, 36, 55, EPD_LGRAY);\n    display.drawCircle(170, 36, 70, EPD_LGRAY);\n    display.drawCircle(170, 36, 75, EPD_LGRAY);\n    display.drawCircle(0, 36, 135, EPD_LGRAY);\n    display.drawCircle(0, 36, 120, EPD_LGRAY);\n    display.drawCircle(0, 36, 95, EPD_LGRAY);\n    display.setTextSize(1);\n    display.setCursor(0, 52);\n    display.print(\nPlease dbl-tap to wakeup\n increase the counter!\n);\n    display.update();\n\n    accel.begin();\n    accel.activateTapOnInt1();\n}\n\nvoid loop() {\n    System.sleep(SLEEP_MODE_DEEP, 3600);\n}\n\n\n\n\nIn the next example we\u2019ll see how to use the accelerometer interrupt to wake-up a micro controller. This enables us to put the MCU in deep-sleep for most of the times which is a good approach to reduce the overall power consumption.", 
            "title": "WakeOnTap"
        }, 
        {
            "location": "/exampleWakeOnTap/#example-6-wakeontap", 
            "text": "After having learned the basics about driving an E-paper screen let\u2019s have a look at the integrated accelerometer. One of its nice features is the supported Tap detection. This allows you to trigger an interrupt, setting a GPIO pin HIGH which can be detected by your micro controller. This setup allows you to add a cheap feedback loop to your projects by implementing a kind of single touch emulation.", 
            "title": "Example 6: WakeOnTap"
        }, 
        {
            "location": "/exampleWakeOnTap/#accelerometer-tap-detection", 
            "text": "The following sketch shows you who to detect a finger tap and increase a counter based on the users input.", 
            "title": "Accelerometer: Tap detection"
        }, 
        {
            "location": "/exampleWakeOnTap/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/exampleWakeOnTap/#sketch", 
            "text": "SYSTEM_MODE(SEMI_AUTOMATIC);\nSTARTUP(System.enableFeature(FEATURE_RETAINED_MEMORY));\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n#define ACC_CS      D0\n\n#include  Adafruit_GFX.h \n#include  PL_microEPD.h \n#include  BO_BMA250E.h \n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  \nBO_BMA250   accel(ACC_CS);\nretained int i = 0;\n\nvoid setup() {\n    SPI.begin();\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    i+=1;\n    display.begin(false);\n    display.setTextSize(6);\n    display.setCursor(0,4);\n    display.print(i);\n    display.drawCircle(170, 36, 40, EPD_LGRAY);\n    display.drawCircle(170, 36, 45, EPD_LGRAY);\n    display.drawCircle(170, 36, 50, EPD_LGRAY);\n    display.drawCircle(170, 36, 55, EPD_LGRAY);\n    display.drawCircle(170, 36, 70, EPD_LGRAY);\n    display.drawCircle(170, 36, 75, EPD_LGRAY);\n    display.drawCircle(0, 36, 135, EPD_LGRAY);\n    display.drawCircle(0, 36, 120, EPD_LGRAY);\n    display.drawCircle(0, 36, 95, EPD_LGRAY);\n    display.setTextSize(1);\n    display.setCursor(0, 52);\n    display.print( Please dbl-tap to wakeup  increase the counter! );\n    display.update();\n\n    accel.begin();\n    accel.activateTapOnInt1();\n}\n\nvoid loop() {\n    System.sleep(SLEEP_MODE_DEEP, 3600);\n}  In the next example we\u2019ll see how to use the accelerometer interrupt to wake-up a micro controller. This enables us to put the MCU in deep-sleep for most of the times which is a good approach to reduce the overall power consumption.", 
            "title": "Sketch"
        }
    ]
}