{
    "docs": [
        {
            "location": "/hookup/", 
            "text": "Hookup Guide\n\n\nThe tutorial is split into the following three sections:\n\n\n\n\n1) Hardware Hookup\n \u2013 How to connect the breakout board with your microcontroller.\n\n\n2) Including the Adafruit GFX library\n \u2013 How to include the library.\n\n\n3) Verifying the pin mapping\n \u2013 Review the pin mapping and adjust if necessary.\n\n\n\n\n1) Hardware Hookup\n\n\n\n\n\n\nNow it\u2019s time to wire things up! The breakout board provides access to 12 pins. The following table provides an overview of how the connect the pins for some typical Arduino MCUs:\n\n\n\n\n\n\n\n\n#\n\n\nPin\n\n\nFunction\n\n\nPhoton* / Electron / Bluz\n\n\nArduino MKRFOX1200\n\n\nNodeMCU\n\n\nWeMos D1 Mini\n\n\n\n\n\n\n\n\n\n\n1\n\n\nMOS\n\n\nSPI MOSI\n\n\nA5\n\n\nMOSI\n\n\n\n\n\n\n\n\n\n\n2\n\n\nMIS\n\n\nSPI MISO\n\n\nA4\n\n\nMISO\n\n\n\n\n\n\n\n\n\n\n3\n\n\nCLK\n\n\nSPI clock\n\n\nA3\n\n\nSCK\n\n\n\n\n\n\n\n\n\n\n4\n\n\nCS1\n\n\nSPI chip select for ePaper driver IC\n\n\nA2**\n\n\nA2**\n\n\n\n\n\n\n\n\n\n\n5\n\n\nRST\n\n\nDigital pin to reset driver IC UC8156\n\n\nA0**\n\n\nA0**\n\n\n\n\n\n\n\n\n\n\n6\n\n\nBSY\n\n\nDigital pin to sense activity state of driver IC UC8156\n\n\nA1**\n\n\nA1**\n\n\n\n\n\n\n\n\n\n\n7\n\n\n3V3\n\n\nRegulated 3.3V power supply\n\n\n3V3\n\n\nVCC\n\n\n\n\n\n\n\n\n\n\n8\n\n\nGND\n\n\nGround\n\n\nGND\n\n\nGND\n\n\n\n\n\n\n\n\n\n\n9\n\n\n-\n\n\n(unused)\n\n\n(unused)\n\n\n(unused)\n\n\n\n\n\n\n\n\n\n\n10\n\n\nCS2\n\n\nSPI chip select for accelerometer IC\n\n\nD6**\n\n\nA6**\n\n\n\n\n\n\n\n\n\n\n11\n\n\nIN2\n\n\nInterrupt line #2, e.g. for tap sensing\n\n\nWKP**\n\n\nA5**\n\n\n\n\n\n\n\n\n\n\n12\n\n\nIN1\n\n\nInterrupt line #1, e.g. for wake-up of deep sleeping MCU\n\n\nWKP**\n\n\n(not supported)\n\n\n\n\n\n\n\n\n\n\n\n\n* Same wiring as for Paperino Shield for Particle used\n** or any other free GPIO pin\n\n\n2) Using the Adafruit GFX Library with Paperino E-Paper display\n\n\nNow that we have wired-up the Paperino breakout board with the MCU, it\u2019s time to get started writing your own application! For this we\u2019ll need to include the \nAdafruit GFX library\n and the hardware-specific library \nPL_microEPD\n. The integration varies depending on your used IDE.\n\n\nParticle Web-IDE\n\n\nIf you are using the Particle Web-IDE, then please start by going to the Library Manager and search for \nPL_microEPD\n. Select one of the demos, i.e. \n_01_HelloWorld.ino\n and click on the button \nUse this example.\n This pastes a copy of the demo into your private App section. Now let\u2019s repeat this step again by searching for \nAdafruit_GFX\n and add this library to this demo file by pressing the button \nInclude in Project\n.\n\n\nArduino Web-IDE\n\n\nIf you are developing sketches with the Arduino Web-IDE\n\n\nArduino-IDE\n\n\n3) Verifying the pin mapping\n\n\nAfter you have included the library, its time to review and verify the pin mapping with the available pins of your used microcontroller:\n\n\n#define EPD_RST     A0      // Reset pin, used to restart the driver IC\n#define EPD_BUSY    A1      // Busy pin, used to sense the activity state of the driver IC\n#define EPD_CS      A2      // Chip select pin, used to select the EPD driver IC\n\n\n\nThat wasn\u2019t too difficult, right? If you are interested in how to write more complex features on the ePaper we suggest starting with the examples section.", 
            "title": "Hookup guide"
        }, 
        {
            "location": "/hookup/#hookup-guide", 
            "text": "The tutorial is split into the following three sections:   1) Hardware Hookup  \u2013 How to connect the breakout board with your microcontroller.  2) Including the Adafruit GFX library  \u2013 How to include the library.  3) Verifying the pin mapping  \u2013 Review the pin mapping and adjust if necessary.", 
            "title": "Hookup Guide"
        }, 
        {
            "location": "/hookup/#1-hardware-hookup", 
            "text": "Now it\u2019s time to wire things up! The breakout board provides access to 12 pins. The following table provides an overview of how the connect the pins for some typical Arduino MCUs:     #  Pin  Function  Photon* / Electron / Bluz  Arduino MKRFOX1200  NodeMCU  WeMos D1 Mini      1  MOS  SPI MOSI  A5  MOSI      2  MIS  SPI MISO  A4  MISO      3  CLK  SPI clock  A3  SCK      4  CS1  SPI chip select for ePaper driver IC  A2**  A2**      5  RST  Digital pin to reset driver IC UC8156  A0**  A0**      6  BSY  Digital pin to sense activity state of driver IC UC8156  A1**  A1**      7  3V3  Regulated 3.3V power supply  3V3  VCC      8  GND  Ground  GND  GND      9  -  (unused)  (unused)  (unused)      10  CS2  SPI chip select for accelerometer IC  D6**  A6**      11  IN2  Interrupt line #2, e.g. for tap sensing  WKP**  A5**      12  IN1  Interrupt line #1, e.g. for wake-up of deep sleeping MCU  WKP**  (not supported)       * Same wiring as for Paperino Shield for Particle used\n** or any other free GPIO pin", 
            "title": "1) Hardware Hookup"
        }, 
        {
            "location": "/hookup/#2-using-the-adafruit-gfx-library-with-paperino-e-paper-display", 
            "text": "Now that we have wired-up the Paperino breakout board with the MCU, it\u2019s time to get started writing your own application! For this we\u2019ll need to include the  Adafruit GFX library  and the hardware-specific library  PL_microEPD . The integration varies depending on your used IDE.", 
            "title": "2) Using the Adafruit GFX Library with Paperino E-Paper display"
        }, 
        {
            "location": "/hookup/#particle-web-ide", 
            "text": "If you are using the Particle Web-IDE, then please start by going to the Library Manager and search for  PL_microEPD . Select one of the demos, i.e.  _01_HelloWorld.ino  and click on the button  Use this example.  This pastes a copy of the demo into your private App section. Now let\u2019s repeat this step again by searching for  Adafruit_GFX  and add this library to this demo file by pressing the button  Include in Project .", 
            "title": "Particle Web-IDE"
        }, 
        {
            "location": "/hookup/#arduino-web-ide", 
            "text": "If you are developing sketches with the Arduino Web-IDE", 
            "title": "Arduino Web-IDE"
        }, 
        {
            "location": "/hookup/#arduino-ide", 
            "text": "", 
            "title": "Arduino-IDE"
        }, 
        {
            "location": "/hookup/#3-verifying-the-pin-mapping", 
            "text": "After you have included the library, its time to review and verify the pin mapping with the available pins of your used microcontroller:  #define EPD_RST     A0      // Reset pin, used to restart the driver IC\n#define EPD_BUSY    A1      // Busy pin, used to sense the activity state of the driver IC\n#define EPD_CS      A2      // Chip select pin, used to select the EPD driver IC  That wasn\u2019t too difficult, right? If you are interested in how to write more complex features on the ePaper we suggest starting with the examples section.", 
            "title": "3) Verifying the pin mapping"
        }, 
        {
            "location": "/exampleHelloWorld/", 
            "text": "Example 1: Hello World!\n\n\nIn this first section we show you how to initialize the ePaper display and write \u201cHello World!\u201d on the screen. It is the shortest possible demo, you will see it\u2019s really simple!\n\n\nDemo\n\n\n\n\nSketch\n\n\nNow let\u2019s have a look at the code: The first lines in the setup section are required to define the SPI settings needed to communicate with the display IC. Before you can talk to your display, the function \nbegin()\n needs to be called once in the \nsetup()\n loop.  This initialises your ePaper screen and resets it to a solid white background. To write text, the function \nprint()\n or \nprintln()\n can be used. Call \nupdate()\n to actually trigger an update. This refresh the screen with the content of the previously filled image buffer. The running demo should look like the video in the section above.\n\n\n#include \nAdafruit_GFX.h\n\n#include \nPL_microEPD.h\n\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  \n\nvoid setup() {  \n    SPI.begin();                    // SPI-Bus initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();                // Paperino ePaper initialisation and refresh screen \n    display.println(\nHello World!\n);// Write message into memory buffer\n    display.update();               // Trigger a full image update\n}\n\nvoid loop() {              \n}\n\n\n\n\nAre you interested in printing more complicated things on the screen? Then let\u2019s proceed with the following \nGFX example\n, which shows you how to draw text in different sizes and how to draw graphic elements like lines, circles \n rectangles.", 
            "title": "Hello World!"
        }, 
        {
            "location": "/exampleHelloWorld/#example-1-hello-world", 
            "text": "In this first section we show you how to initialize the ePaper display and write \u201cHello World!\u201d on the screen. It is the shortest possible demo, you will see it\u2019s really simple!", 
            "title": "Example 1: Hello World!"
        }, 
        {
            "location": "/exampleHelloWorld/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/exampleHelloWorld/#sketch", 
            "text": "Now let\u2019s have a look at the code: The first lines in the setup section are required to define the SPI settings needed to communicate with the display IC. Before you can talk to your display, the function  begin()  needs to be called once in the  setup()  loop.  This initialises your ePaper screen and resets it to a solid white background. To write text, the function  print()  or  println()  can be used. Call  update()  to actually trigger an update. This refresh the screen with the content of the previously filled image buffer. The running demo should look like the video in the section above.  #include  Adafruit_GFX.h \n#include  PL_microEPD.h \n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  \n\nvoid setup() {  \n    SPI.begin();                    // SPI-Bus initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();                // Paperino ePaper initialisation and refresh screen \n    display.println( Hello World! );// Write message into memory buffer\n    display.update();               // Trigger a full image update\n}\n\nvoid loop() {              \n}  Are you interested in printing more complicated things on the screen? Then let\u2019s proceed with the following  GFX example , which shows you how to draw text in different sizes and how to draw graphic elements like lines, circles   rectangles.", 
            "title": "Sketch"
        }, 
        {
            "location": "/exampleGFXdemo/", 
            "text": "Example 2: GFX Graphics demo\n\n\nIn the \nprevious example\n we learned how to initialise the ePaper screen and write \u201cHello World!\u201d on it. Now let\u2019s try some more complicated features! In this chapter we will learn how to change the size and the position of the text and how to change the text font. Afterwards we will see how easy it is to draw some graphic elements on the display. The last section contains the sketch for an executable demo to try out by yourself.\n\n\nCharacters and Text\n\n\nThe \nAdafruit GFX Graphics library\n provides many easy to use functions to write characters and text on the screen. Typical functions are: \ndrawChar()\n, \nsetCursor()\n, \nsetTextColor()\n, \nsetTextSize()\n, \nsetFont()\n, \nsetTextWrap()\n. A good starting point for more detailed syntax and information is \nthis learning site\n.\n\n\nGraphics\n\n\nFor drawing graphics like circles, rectangles or triangles, the GFX library provides this typical functions: \ndrawPixel()\n, \ndrawLine()\n, \ndrawRect()\n, \nfillRect()\n, \ndrawCircle()\n, \nfillCircle()\n, \ndrawRoundRect()\n, \nfillRoundRect()\n, \ndrawTriangle()\n, \ndrawfillTriangle()\n. Again, please head over to Adafruits \nlearning site\n for more information.\n\n\nDemo\n\n\n\n\nSketch\n\n\nThe following sketch starts with a loop which draws a sequence of ASCII characters on the screen using the function \ndrawChar()\n. The next section shows how to set the font size based on the function \nsetTextSize()\n. Inverting of the screen content can be done with \ninvert()\n. The last part of the sketch shows how to draw some rectangles, filled rectangles and circles. \n\n\n#include \nAdafruit_GFX.h\n\n#include \nPL_microEPD.h\n\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY); \nint i=0;\n\nvoid setup() {\n    SPI.begin();                            // SPI initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();                        // Paperino ePaper initialisation and refresh screen \n    for (int y=0; y \n 6; y++) {\n        for (int x=0; x \n 26; x++) {\n            i=i+1;                          // Draw some ASCII characters\n            display.drawChar(1+x*7,1+y*11,i,0,3,1);\n        }   \n    }\n    display.update();                       // Trigger a full image update\n    delay(5000);\n\n    display.clear();                        // Clear the image buffer\n    display.setCursor(1,1);                 // Set Cursor start position \n    display.println(\nSize1\n);\n    display.setTextSize(2);                 // Change text size\n    display.println(\nSize2\n);\n    display.setTextSize(3);\n    display.println(\nSize3\n);\n    display.setCursor(100,5);\n    display.setTextSize(9);\n    display.println(\n9\n);\n    display.update();                       // Trigger a full image update\n    delay(5000);\n\n    display.invert();                       // Invert the display content\n    display.update();\n    delay(5000);\n\n    display.clear();\n    display.drawRect(5, 5, 50, 50, EPD_BLACK);          // Draw a rectangle\n    display.fillRect(40,40,25,25, EPD_BLACK);        // Draw a filled rectangle \n    display.drawCircle(100, 35, 30, EPD_BLACK);        // Draw a circle\n    display.drawCircle(100, 35, 15, EPD_BLACK);\n    display.drawCircle(100, 35, 8, EPD_BLACK);\n    display.drawCircle(100, 35, 4, EPD_BLACK);\n    display.update();\n    delay(5000);\n\n    display.clear();\n    display.setTextSize(2);\n    display.setCursor(5, 20);\n    display.println(\nHello\n);\n    display.setCursor(5, 36);\n    display.println(\nWorld!\n);\n    display.drawCircle(170, 36, 40, EPD_BLACK);\n    display.drawCircle(170, 36, 45, EPD_BLACK);\n    display.drawCircle(170, 36, 50, EPD_BLACK);\n    display.drawCircle(170, 36, 55, EPD_BLACK);\n    display.drawCircle(170, 36, 70, EPD_BLACK);\n    display.drawCircle(170, 36, 75, EPD_BLACK);\n    display.drawCircle(0, 36, 135, EPD_BLACK);\n    display.drawCircle(0, 36, 120, EPD_BLACK);\n    display.drawCircle(0, 36, 75, EPD_BLACK);\n    display.invert();\n    display.update();\n}\n\nvoid loop() {\n}\n\n\n\n\nSo far we used black as primary color for drawing the graphic elements. The next example will show you how to change the color and how to add the intermediate colours lightgray and darkgray. Interested? Then let\u2019s proceed \nhere\n.", 
            "title": "GFX demo"
        }, 
        {
            "location": "/exampleGFXdemo/#example-2-gfx-graphics-demo", 
            "text": "In the  previous example  we learned how to initialise the ePaper screen and write \u201cHello World!\u201d on it. Now let\u2019s try some more complicated features! In this chapter we will learn how to change the size and the position of the text and how to change the text font. Afterwards we will see how easy it is to draw some graphic elements on the display. The last section contains the sketch for an executable demo to try out by yourself.", 
            "title": "Example 2: GFX Graphics demo"
        }, 
        {
            "location": "/exampleGFXdemo/#characters-and-text", 
            "text": "The  Adafruit GFX Graphics library  provides many easy to use functions to write characters and text on the screen. Typical functions are:  drawChar() ,  setCursor() ,  setTextColor() ,  setTextSize() ,  setFont() ,  setTextWrap() . A good starting point for more detailed syntax and information is  this learning site .", 
            "title": "Characters and Text"
        }, 
        {
            "location": "/exampleGFXdemo/#graphics", 
            "text": "For drawing graphics like circles, rectangles or triangles, the GFX library provides this typical functions:  drawPixel() ,  drawLine() ,  drawRect() ,  fillRect() ,  drawCircle() ,  fillCircle() ,  drawRoundRect() ,  fillRoundRect() ,  drawTriangle() ,  drawfillTriangle() . Again, please head over to Adafruits  learning site  for more information.", 
            "title": "Graphics"
        }, 
        {
            "location": "/exampleGFXdemo/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/exampleGFXdemo/#sketch", 
            "text": "The following sketch starts with a loop which draws a sequence of ASCII characters on the screen using the function  drawChar() . The next section shows how to set the font size based on the function  setTextSize() . Inverting of the screen content can be done with  invert() . The last part of the sketch shows how to draw some rectangles, filled rectangles and circles.   #include  Adafruit_GFX.h \n#include  PL_microEPD.h \n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY); \nint i=0;\n\nvoid setup() {\n    SPI.begin();                            // SPI initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();                        // Paperino ePaper initialisation and refresh screen \n    for (int y=0; y   6; y++) {\n        for (int x=0; x   26; x++) {\n            i=i+1;                          // Draw some ASCII characters\n            display.drawChar(1+x*7,1+y*11,i,0,3,1);\n        }   \n    }\n    display.update();                       // Trigger a full image update\n    delay(5000);\n\n    display.clear();                        // Clear the image buffer\n    display.setCursor(1,1);                 // Set Cursor start position \n    display.println( Size1 );\n    display.setTextSize(2);                 // Change text size\n    display.println( Size2 );\n    display.setTextSize(3);\n    display.println( Size3 );\n    display.setCursor(100,5);\n    display.setTextSize(9);\n    display.println( 9 );\n    display.update();                       // Trigger a full image update\n    delay(5000);\n\n    display.invert();                       // Invert the display content\n    display.update();\n    delay(5000);\n\n    display.clear();\n    display.drawRect(5, 5, 50, 50, EPD_BLACK);          // Draw a rectangle\n    display.fillRect(40,40,25,25, EPD_BLACK);        // Draw a filled rectangle \n    display.drawCircle(100, 35, 30, EPD_BLACK);        // Draw a circle\n    display.drawCircle(100, 35, 15, EPD_BLACK);\n    display.drawCircle(100, 35, 8, EPD_BLACK);\n    display.drawCircle(100, 35, 4, EPD_BLACK);\n    display.update();\n    delay(5000);\n\n    display.clear();\n    display.setTextSize(2);\n    display.setCursor(5, 20);\n    display.println( Hello );\n    display.setCursor(5, 36);\n    display.println( World! );\n    display.drawCircle(170, 36, 40, EPD_BLACK);\n    display.drawCircle(170, 36, 45, EPD_BLACK);\n    display.drawCircle(170, 36, 50, EPD_BLACK);\n    display.drawCircle(170, 36, 55, EPD_BLACK);\n    display.drawCircle(170, 36, 70, EPD_BLACK);\n    display.drawCircle(170, 36, 75, EPD_BLACK);\n    display.drawCircle(0, 36, 135, EPD_BLACK);\n    display.drawCircle(0, 36, 120, EPD_BLACK);\n    display.drawCircle(0, 36, 75, EPD_BLACK);\n    display.invert();\n    display.update();\n}\n\nvoid loop() {\n}  So far we used black as primary color for drawing the graphic elements. The next example will show you how to change the color and how to add the intermediate colours lightgray and darkgray. Interested? Then let\u2019s proceed  here .", 
            "title": "Sketch"
        }, 
        {
            "location": "/example4GLs/", 
            "text": "Example 3: 4 Graylevels\n\n\nIn the \nprevious examples\n we always use black as primary color for drawing something on the screen. In this chapter we will see how to change the color and make use of the four supported gray levels: White, Light Gray, Dark Gray and Black.\n\n\nColors\n\n\nThis E-paper library uses the following definitions to set a color \nEPD_WHITE\n, \nEPD_LGRAY\n, \nEPD_DGRAY\n and \nEPD_BLACK\n. They can be used for all graphic elements and for characters and text via the function \nsetTextColor()\n. Please have a look at the following sketch.\n\n\nDemo\n\n\n\n\nSketch\n\n\n#include \nAdafruit_GFX.h\n\n#include \nPL_microEPD.h\n\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);\n\nvoid setup() {\n    SPI.begin();                    // SPI-Bus initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();                // Paperino ePaper initialisation and refresh screen\n\n    display.setCursor(8,28);\n    display.setTextSize(2);\n    display.println(\nGray Levels\n);\n    display.update();\n    delay(2000);\n\n    display.clear();\n    display.setCursor(45,15);\n    display.println(\nBlack\n);\n    display.update();\n    delay(500);\n    display.fillRect(10, 37, 128, 25, EPD_BLACK);   // Color = BLACK\n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.setCursor(19,15);\n    display.println(\nDark Gray\n);\n    display.update();\n    delay(500);\n    display.fillRect(10, 37, 128, 25, EPD_DGRAY);   // Color = DARK GRAY\n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.setCursor(15,15);\n    display.println(\nLight Gray\n);\n    display.update();\n    delay(500);\n    display.fillRect(10, 37, 128, 25, EPD_LGRAY);   // Color = LIGHT GRAY\n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.setCursor(45,15);\n    display.println(\nWhite\n);\n    display.update();\n    delay(500);\n    display.drawRect(10, 37, 128, 25, EPD_BLACK);   \n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.drawRect(9, 21, 130, 30, EPD_BLACK);\n    display.update();\n    display.fillRect(10, 22, 33, 28, EPD_BLACK);\n    display.update(EPD_UPD_PART);\n    display.fillRect(43, 22, 33, 28, EPD_DGRAY);\n    display.update(EPD_UPD_PART);\n    display.fillRect(76, 22, 32, 28, EPD_LGRAY);\n    display.update(EPD_UPD_PART);\n}\n\nvoid loop() {\n}\n\n\n\n\nUpto now, each update refreshed all the pixels no matter they were changing or not. In the next section we will see how to make use of so called partial update modes of the Epaper screen. If you are interested please head over \nhere\n.", 
            "title": "Graylevels"
        }, 
        {
            "location": "/example4GLs/#example-3-4-graylevels", 
            "text": "In the  previous examples  we always use black as primary color for drawing something on the screen. In this chapter we will see how to change the color and make use of the four supported gray levels: White, Light Gray, Dark Gray and Black.", 
            "title": "Example 3: 4 Graylevels"
        }, 
        {
            "location": "/example4GLs/#colors", 
            "text": "This E-paper library uses the following definitions to set a color  EPD_WHITE ,  EPD_LGRAY ,  EPD_DGRAY  and  EPD_BLACK . They can be used for all graphic elements and for characters and text via the function  setTextColor() . Please have a look at the following sketch.", 
            "title": "Colors"
        }, 
        {
            "location": "/example4GLs/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/example4GLs/#sketch", 
            "text": "#include  Adafruit_GFX.h \n#include  PL_microEPD.h \n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);\n\nvoid setup() {\n    SPI.begin();                    // SPI-Bus initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();                // Paperino ePaper initialisation and refresh screen\n\n    display.setCursor(8,28);\n    display.setTextSize(2);\n    display.println( Gray Levels );\n    display.update();\n    delay(2000);\n\n    display.clear();\n    display.setCursor(45,15);\n    display.println( Black );\n    display.update();\n    delay(500);\n    display.fillRect(10, 37, 128, 25, EPD_BLACK);   // Color = BLACK\n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.setCursor(19,15);\n    display.println( Dark Gray );\n    display.update();\n    delay(500);\n    display.fillRect(10, 37, 128, 25, EPD_DGRAY);   // Color = DARK GRAY\n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.setCursor(15,15);\n    display.println( Light Gray );\n    display.update();\n    delay(500);\n    display.fillRect(10, 37, 128, 25, EPD_LGRAY);   // Color = LIGHT GRAY\n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.setCursor(45,15);\n    display.println( White );\n    display.update();\n    delay(500);\n    display.drawRect(10, 37, 128, 25, EPD_BLACK);   \n    display.update(EPD_UPD_PART);\n    delay(2000);\n\n    display.clear();\n    display.drawRect(9, 21, 130, 30, EPD_BLACK);\n    display.update();\n    display.fillRect(10, 22, 33, 28, EPD_BLACK);\n    display.update(EPD_UPD_PART);\n    display.fillRect(43, 22, 33, 28, EPD_DGRAY);\n    display.update(EPD_UPD_PART);\n    display.fillRect(76, 22, 32, 28, EPD_LGRAY);\n    display.update(EPD_UPD_PART);\n}\n\nvoid loop() {\n}  Upto now, each update refreshed all the pixels no matter they were changing or not. In the next section we will see how to make use of so called partial update modes of the Epaper screen. If you are interested please head over  here .", 
            "title": "Sketch"
        }, 
        {
            "location": "/exampleUpdateMode/", 
            "text": "Example 4: Update Modes\n\n\nIn the previous examples, we learned how to \ninitialise\n the display, how to write different \ngraphics \n text\n and how to use different \ngraylevels\n. Now let\u2019s have a look at three different ways how to update an ePaper screen. \n\n\nUpdate Modes\n\n\nThe E-Paper library defines the following three update modes \nEPD_UPD_FULL\n, \nEPD_UPD_PART\n and \nEPD_MONO\n.\n\nEPD_UPD_FULL\n is set by default, achieves four graylevels, takes about 800ms and refreshes all pixels. This is the update mode having the best image quality. \nEPD_UPD_PART\n is a variant of the previous one but only changing pixels are refreshed. This results in less flickering for the price of a slightly higher pixel to pixel crosstalk. \nEPD_MONO\n is again a variant of the previous update mode but only about 250ms long. This allows slightly faster and more responsive updates for the price of supporting only two graylevels (\nEPD_BLACK\n and \nEPD_WHITE\n). Depending on your application it is recommended to insert a full update \nEPD_UPD_FULL\n after a couple of mono updates to increase the image quality. \n\n\nDemo\n\n\n\n\nSketch\n\n\n#include \nAdafruit_GFX.h\n\n#include \nPL_microEPD.h\n\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY); \n\n\nvoid setup() {\n    SPI.begin();                            // SPI initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n    display.begin();                        // Paperino ePaper initialisation and refresh screen \n\n    display.setTextSize(2);\n    display.println(\nUpdate Modes\n);\n    display.setTextSize(1);\n    display.println(\n-Full Update\n);\n    display.println(\n-Partial Update\n);          \n    display.println(\n-Partial Mono Update\n);          \n    display.update();                       // Triggers a Full update, 4 GL, 800ms\n\n    delay(4000);\n    display.clear();\n    display.setTextSize(2);\n    display.print(\nEPD_UPD_FULL\n);          \n    display.update();                       // Triggers a Full update, 4 GL, 800ms\n    delay(1000);\n    display.setTextSize(1);\n    display.print(\nThis is a \n);\n    display.setTextColor(EPD_WHITE, EPD_BLACK);\n    display.println(\nfull update.\n);\n    display.update();                   \n    delay(1000);\n    display.setTextColor(EPD_BLACK, EPD_WHITE);\n    display.println(\nAll pixels are reset no matter whether they are changing or not.\n);\n    display.update();\n    delay(2000);\n    display.println(\nHm, a bit boring, isn't it...?\n);\n    display.update();\n\n    delay(4000);\n    display.clear();\n    display.setTextSize(2);\n    display.print(\nEPD_UPD_PART\n);                 \n    display.update(EPD_UPD_PART);           // Triggers a Partial update, 4 GL, 800ms\n    delay(1000);\n    display.setTextSize(1);\n    display.print(\nOK! Now you see \n);\n    display.setTextColor(EPD_WHITE, EPD_BLACK);\n    display.print(\npartial updates!\n);\n    display.update(EPD_UPD_PART);                \n    delay(1000);\n    display.setTextColor(EPD_BLACK, EPD_WHITE);\n    display.print(\n Only changing  pixels are updated. \n);\n    display.update(EPD_UPD_PART);\n    delay(1000);\n    display.print(\nThisgenerates less flicker  and results in lower    power consumption. \n);\n    display.update(EPD_UPD_PART);\n\n    delay(4000);\n    display.clear();\n    display.setTextSize(2);\n    display.print(\nEPD_UPD_MONO\n);                 \n    display.update(EPD_UPD_MONO);           // Triggers a Partial Mono update, 2 GL, 250ms\n    delay(1000);\n    display.setTextSize(1);\n    display.setTextColor(EPD_WHITE, EPD_BLACK);\n    display.print(\nMono updates\n);\n    display.setTextColor(EPD_BLACK, EPD_WHITE);\n    display.print(\n allow a bitfaster update rates \n);\n    display.update(EPD_UPD_MONO);                \n    delay(1000);\n    display.print(\n(butsupport only two grey-  levels).\n);\n    display.update(EPD_UPD_MONO);\n\n    delay(1000);\n    display.drawRect(9, 51, 125, 14, 0);\n    display.update(EPD_UPD_MONO);\n    for (int i=1; i\n18; i++) {\n        display.fillRect(6 + 7*i, 53, 5, 10, 0);\n        display.update(EPD_UPD_MONO);\n    }\n}\n\nvoid loop() {\n}\n\n\n\n\nCongratulation! You now learned the basics of running an ePaper screen. Interested in more? In the next examples we learn how to make use of the integrated accelerometer as a cheap touch emulator.", 
            "title": "Update Modes"
        }, 
        {
            "location": "/exampleUpdateMode/#example-4-update-modes", 
            "text": "In the previous examples, we learned how to  initialise  the display, how to write different  graphics   text  and how to use different  graylevels . Now let\u2019s have a look at three different ways how to update an ePaper screen.", 
            "title": "Example 4: Update Modes"
        }, 
        {
            "location": "/exampleUpdateMode/#update-modes", 
            "text": "The E-Paper library defines the following three update modes  EPD_UPD_FULL ,  EPD_UPD_PART  and  EPD_MONO . EPD_UPD_FULL  is set by default, achieves four graylevels, takes about 800ms and refreshes all pixels. This is the update mode having the best image quality.  EPD_UPD_PART  is a variant of the previous one but only changing pixels are refreshed. This results in less flickering for the price of a slightly higher pixel to pixel crosstalk.  EPD_MONO  is again a variant of the previous update mode but only about 250ms long. This allows slightly faster and more responsive updates for the price of supporting only two graylevels ( EPD_BLACK  and  EPD_WHITE ). Depending on your application it is recommended to insert a full update  EPD_UPD_FULL  after a couple of mono updates to increase the image quality.", 
            "title": "Update Modes"
        }, 
        {
            "location": "/exampleUpdateMode/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/exampleUpdateMode/#sketch", 
            "text": "#include  Adafruit_GFX.h \n#include  PL_microEPD.h \n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY); \n\n\nvoid setup() {\n    SPI.begin();                            // SPI initialisation\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n    display.begin();                        // Paperino ePaper initialisation and refresh screen \n\n    display.setTextSize(2);\n    display.println( Update Modes );\n    display.setTextSize(1);\n    display.println( -Full Update );\n    display.println( -Partial Update );          \n    display.println( -Partial Mono Update );          \n    display.update();                       // Triggers a Full update, 4 GL, 800ms\n\n    delay(4000);\n    display.clear();\n    display.setTextSize(2);\n    display.print( EPD_UPD_FULL );          \n    display.update();                       // Triggers a Full update, 4 GL, 800ms\n    delay(1000);\n    display.setTextSize(1);\n    display.print( This is a  );\n    display.setTextColor(EPD_WHITE, EPD_BLACK);\n    display.println( full update. );\n    display.update();                   \n    delay(1000);\n    display.setTextColor(EPD_BLACK, EPD_WHITE);\n    display.println( All pixels are reset no matter whether they are changing or not. );\n    display.update();\n    delay(2000);\n    display.println( Hm, a bit boring, isn't it...? );\n    display.update();\n\n    delay(4000);\n    display.clear();\n    display.setTextSize(2);\n    display.print( EPD_UPD_PART );                 \n    display.update(EPD_UPD_PART);           // Triggers a Partial update, 4 GL, 800ms\n    delay(1000);\n    display.setTextSize(1);\n    display.print( OK! Now you see  );\n    display.setTextColor(EPD_WHITE, EPD_BLACK);\n    display.print( partial updates! );\n    display.update(EPD_UPD_PART);                \n    delay(1000);\n    display.setTextColor(EPD_BLACK, EPD_WHITE);\n    display.print(  Only changing  pixels are updated.  );\n    display.update(EPD_UPD_PART);\n    delay(1000);\n    display.print( Thisgenerates less flicker  and results in lower    power consumption.  );\n    display.update(EPD_UPD_PART);\n\n    delay(4000);\n    display.clear();\n    display.setTextSize(2);\n    display.print( EPD_UPD_MONO );                 \n    display.update(EPD_UPD_MONO);           // Triggers a Partial Mono update, 2 GL, 250ms\n    delay(1000);\n    display.setTextSize(1);\n    display.setTextColor(EPD_WHITE, EPD_BLACK);\n    display.print( Mono updates );\n    display.setTextColor(EPD_BLACK, EPD_WHITE);\n    display.print(  allow a bitfaster update rates  );\n    display.update(EPD_UPD_MONO);                \n    delay(1000);\n    display.print( (butsupport only two grey-  levels). );\n    display.update(EPD_UPD_MONO);\n\n    delay(1000);\n    display.drawRect(9, 51, 125, 14, 0);\n    display.update(EPD_UPD_MONO);\n    for (int i=1; i 18; i++) {\n        display.fillRect(6 + 7*i, 53, 5, 10, 0);\n        display.update(EPD_UPD_MONO);\n    }\n}\n\nvoid loop() {\n}  Congratulation! You now learned the basics of running an ePaper screen. Interested in more? In the next examples we learn how to make use of the integrated accelerometer as a cheap touch emulator.", 
            "title": "Sketch"
        }, 
        {
            "location": "/exampleTapCounter/", 
            "text": "Example 5: Tap Counter\n\n\nAfter having learned the basics about driving an E-paper screen let\u2019s have a look at the integrated accelerometer. One of its nice features is the supported Tap detection. This allows you to trigger an interrupt, setting a GPIO pin HIGH which can be detected by your micro controller. This setup allows you to add a cheap feedback loop to your projects by implementing a kind of single touch emulation. \n\n\nAccelerometer: Tap detection\n\n\nThe following sketch shows you who to detect a finger tap and increase a counter based on the users input.\n\n\nDemo\n\n\n\n\nSketch\n\n\nSYSTEM_MODE(SEMI_AUTOMATIC);\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n#define ACC_CS      D0\n\n#include \nAdafruit_GFX.h\n\n#include \nPL_microEPD.h\n\n#include \nBO_BMA250E.h\n\n\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  \nBO_BMA250   accel(ACC_CS);\nint         i       = 0;\nbool        status  = false;     //0 = stopped, 1 = running\n\nvoid setup() {\n    pinMode(WKP, INPUT);\n\n    SPI.begin();\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();\n    display.setTextSize(6);\n    display.setCursor(0,4);\n    display.print(i);\n    display.drawCircle(170, 36, 40, EPD_LGRAY);\n    display.drawCircle(170, 36, 45, EPD_LGRAY);\n    display.drawCircle(170, 36, 50, EPD_LGRAY);\n    display.drawCircle(170, 36, 55, EPD_LGRAY);\n    display.drawCircle(170, 36, 70, EPD_LGRAY);\n    display.drawCircle(170, 36, 75, EPD_LGRAY);\n    display.drawCircle(0, 36, 135, EPD_LGRAY);\n    display.drawCircle(0, 36, 120, EPD_LGRAY);\n    display.drawCircle(0, 36, 95, EPD_LGRAY);\n    display.setTextSize(1);\n    display.setCursor(0, 52);\n    display.print(\nPlease tap to increase  the counter!\n);\n    display.update(); \n\n    accel.begin();\n    accel.activateTapOnInt1();\n}\n\nvoid loop() {\n    if (digitalRead(WKP)==HIGH) {\n        status = !status; \n        if (status==true) {\n            i+=1;\n            display.fillRect(0, 4, 70, 43, EPD_WHITE);\n            display.setTextSize(6);\n            display.setCursor(0,4);\n            display.print(i);\n            display.update(EPD_UPD_MONO);\n            status = !status;\n        };\n        delay(1000);\n    };\n}\n\n\n\n\nIn the next example we\u2019ll see how to use the accelerometer interrupt to wake-up a micro controller. This enables us to put the MCU in deep-sleep for most of the times which is a good approach to reduce the overall power consumption.", 
            "title": "Tap Counter"
        }, 
        {
            "location": "/exampleTapCounter/#example-5-tap-counter", 
            "text": "After having learned the basics about driving an E-paper screen let\u2019s have a look at the integrated accelerometer. One of its nice features is the supported Tap detection. This allows you to trigger an interrupt, setting a GPIO pin HIGH which can be detected by your micro controller. This setup allows you to add a cheap feedback loop to your projects by implementing a kind of single touch emulation.", 
            "title": "Example 5: Tap Counter"
        }, 
        {
            "location": "/exampleTapCounter/#accelerometer-tap-detection", 
            "text": "The following sketch shows you who to detect a finger tap and increase a counter based on the users input.", 
            "title": "Accelerometer: Tap detection"
        }, 
        {
            "location": "/exampleTapCounter/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/exampleTapCounter/#sketch", 
            "text": "SYSTEM_MODE(SEMI_AUTOMATIC);\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n#define ACC_CS      D0\n\n#include  Adafruit_GFX.h \n#include  PL_microEPD.h \n#include  BO_BMA250E.h \n\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  \nBO_BMA250   accel(ACC_CS);\nint         i       = 0;\nbool        status  = false;     //0 = stopped, 1 = running\n\nvoid setup() {\n    pinMode(WKP, INPUT);\n\n    SPI.begin();\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    display.begin();\n    display.setTextSize(6);\n    display.setCursor(0,4);\n    display.print(i);\n    display.drawCircle(170, 36, 40, EPD_LGRAY);\n    display.drawCircle(170, 36, 45, EPD_LGRAY);\n    display.drawCircle(170, 36, 50, EPD_LGRAY);\n    display.drawCircle(170, 36, 55, EPD_LGRAY);\n    display.drawCircle(170, 36, 70, EPD_LGRAY);\n    display.drawCircle(170, 36, 75, EPD_LGRAY);\n    display.drawCircle(0, 36, 135, EPD_LGRAY);\n    display.drawCircle(0, 36, 120, EPD_LGRAY);\n    display.drawCircle(0, 36, 95, EPD_LGRAY);\n    display.setTextSize(1);\n    display.setCursor(0, 52);\n    display.print( Please tap to increase  the counter! );\n    display.update(); \n\n    accel.begin();\n    accel.activateTapOnInt1();\n}\n\nvoid loop() {\n    if (digitalRead(WKP)==HIGH) {\n        status = !status; \n        if (status==true) {\n            i+=1;\n            display.fillRect(0, 4, 70, 43, EPD_WHITE);\n            display.setTextSize(6);\n            display.setCursor(0,4);\n            display.print(i);\n            display.update(EPD_UPD_MONO);\n            status = !status;\n        };\n        delay(1000);\n    };\n}  In the next example we\u2019ll see how to use the accelerometer interrupt to wake-up a micro controller. This enables us to put the MCU in deep-sleep for most of the times which is a good approach to reduce the overall power consumption.", 
            "title": "Sketch"
        }, 
        {
            "location": "/exampleWakeOnTap/", 
            "text": "Example 6: WakeOnTap\n\n\nAfter having learned the basics about driving an E-paper screen let\u2019s have a look at the integrated accelerometer. One of its nice features is the supported Tap detection. This allows you to trigger an interrupt, setting a GPIO pin HIGH which can be detected by your micro controller. This setup allows you to add a cheap feedback loop to your projects by implementing a kind of single touch emulation. \n\n\nAccelerometer: Tap detection\n\n\nThe following sketch shows you who to detect a finger tap and increase a counter based on the users input.\n\n\nDemo\n\n\n\n\nSketch\n\n\nSYSTEM_MODE(SEMI_AUTOMATIC);\nSTARTUP(System.enableFeature(FEATURE_RETAINED_MEMORY));\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n#define ACC_CS      D0\n\n#include \nAdafruit_GFX.h\n\n#include \nPL_microEPD.h\n\n#include \nBO_BMA250E.h\n\n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  \nBO_BMA250   accel(ACC_CS);\nretained int i = 0;\n\nvoid setup() {\n    SPI.begin();\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    i+=1;\n    display.begin(false);\n    display.setTextSize(6);\n    display.setCursor(0,4);\n    display.print(i);\n    display.drawCircle(170, 36, 40, EPD_LGRAY);\n    display.drawCircle(170, 36, 45, EPD_LGRAY);\n    display.drawCircle(170, 36, 50, EPD_LGRAY);\n    display.drawCircle(170, 36, 55, EPD_LGRAY);\n    display.drawCircle(170, 36, 70, EPD_LGRAY);\n    display.drawCircle(170, 36, 75, EPD_LGRAY);\n    display.drawCircle(0, 36, 135, EPD_LGRAY);\n    display.drawCircle(0, 36, 120, EPD_LGRAY);\n    display.drawCircle(0, 36, 95, EPD_LGRAY);\n    display.setTextSize(1);\n    display.setCursor(0, 52);\n    display.print(\nPlease dbl-tap to wakeup\n increase the counter!\n);\n    display.update();\n\n    accel.begin();\n    accel.activateTapOnInt1();\n}\n\nvoid loop() {\n    System.sleep(SLEEP_MODE_DEEP, 3600);\n}\n\n\n\n\nIn the next example we\u2019ll see how to use the accelerometer interrupt to wake-up a micro controller. This enables us to put the MCU in deep-sleep for most of the times which is a good approach to reduce the overall power consumption.", 
            "title": "WakeOnTap"
        }, 
        {
            "location": "/exampleWakeOnTap/#example-6-wakeontap", 
            "text": "After having learned the basics about driving an E-paper screen let\u2019s have a look at the integrated accelerometer. One of its nice features is the supported Tap detection. This allows you to trigger an interrupt, setting a GPIO pin HIGH which can be detected by your micro controller. This setup allows you to add a cheap feedback loop to your projects by implementing a kind of single touch emulation.", 
            "title": "Example 6: WakeOnTap"
        }, 
        {
            "location": "/exampleWakeOnTap/#accelerometer-tap-detection", 
            "text": "The following sketch shows you who to detect a finger tap and increase a counter based on the users input.", 
            "title": "Accelerometer: Tap detection"
        }, 
        {
            "location": "/exampleWakeOnTap/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/exampleWakeOnTap/#sketch", 
            "text": "SYSTEM_MODE(SEMI_AUTOMATIC);\nSTARTUP(System.enableFeature(FEATURE_RETAINED_MEMORY));\n\n#define EPD_RST     A0\n#define EPD_BUSY    A1\n#define EPD_CS      A2\n#define ACC_CS      D0\n\n#include  Adafruit_GFX.h \n#include  PL_microEPD.h \n#include  BO_BMA250E.h \n\nPL_microEPD display(EPD_CS, EPD_RST, EPD_BUSY);  \nBO_BMA250   accel(ACC_CS);\nretained int i = 0;\n\nvoid setup() {\n    SPI.begin();\n    SPI.setBitOrder(MSBFIRST);                 \n    SPI.setDataMode(SPI_MODE0); \n    SPI.setClockDivider(SPI_CLOCK_DIV4);\n\n    i+=1;\n    display.begin(false);\n    display.setTextSize(6);\n    display.setCursor(0,4);\n    display.print(i);\n    display.drawCircle(170, 36, 40, EPD_LGRAY);\n    display.drawCircle(170, 36, 45, EPD_LGRAY);\n    display.drawCircle(170, 36, 50, EPD_LGRAY);\n    display.drawCircle(170, 36, 55, EPD_LGRAY);\n    display.drawCircle(170, 36, 70, EPD_LGRAY);\n    display.drawCircle(170, 36, 75, EPD_LGRAY);\n    display.drawCircle(0, 36, 135, EPD_LGRAY);\n    display.drawCircle(0, 36, 120, EPD_LGRAY);\n    display.drawCircle(0, 36, 95, EPD_LGRAY);\n    display.setTextSize(1);\n    display.setCursor(0, 52);\n    display.print( Please dbl-tap to wakeup  increase the counter! );\n    display.update();\n\n    accel.begin();\n    accel.activateTapOnInt1();\n}\n\nvoid loop() {\n    System.sleep(SLEEP_MODE_DEEP, 3600);\n}  In the next example we\u2019ll see how to use the accelerometer interrupt to wake-up a micro controller. This enables us to put the MCU in deep-sleep for most of the times which is a good approach to reduce the overall power consumption.", 
            "title": "Sketch"
        }
    ]
}